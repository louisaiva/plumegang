


 _newfile_ :Z:\DESKTOP\CODING\plumegang/./plume.py


"""
CODED by deltasfer
enjoy
"""


import pyglet,time,random
from pyglet.window import key
import pyglet.gl as gl

from src.utils import *
from src.colors import *
import src.names as names
import src.getsave as gs
from src import obj as o
from src import perso as p
from src import obj2 as o2
from src import graphic as g
from src import menu as m

CURRENT_PATH = os.path.dirname(os.path.abspath(__file__)) # fopatouché
if ' ' in CURRENT_PATH:
    print('Le chemin d\'acces contient un espace. Le programme va BUGUER SA MERE.')
    print('Changez le programme de place pour un path sans espace svp.')

ESK_QUIT = 0
## pour éviter d'avoir à passer par le menu
FILL_INV = 1
## pour remplir ou non l'inventaire au debut

class App():

    ### INIT FUNCTIONS

    def __init__(self):

        self.path = CURRENT_PATH

        ### windows

        self.window = pyglet.window.Window(screen=g.scr.screen)

        self.window.set_fullscreen()

        self.window.push_handlers(self)
        #self.window.screen = self.get_current_screen()

        ### loading fonts
        font_path = 'item/fonts/'
        self.fonts = ['RaubFont']
        self.font = ['RaubFont']
        for ft in self.fonts:
            try:
                pyglet.resource.add_font(font_path+ft+'.otf')
            except:
                try:
                    pyglet.resource.add_font(font_path+ft+'.ttf')
                except :
                    pyglet.resource.add_font('arial.ttf')

        #pyglet.clock.set_fps_limit(None)

        ### managers

        #g.init_managers(CURRENT_PATH,self.font)

        g.lman.updateman(self.font[0])

        #self.cmd = graphic.CmdManager((20 , self.size_fullscr[1] - 50))
        #self.specMan = graphic.SpecialManager(g.tman,self.current_size_scr)

        #self.aff_cmd = False

    def init(self):

        ##  TEXTURES

        self.create_organise_textures()

        ## Cursor
        #image = pyglet.image.load('cursor.png')
        g.Cur.init(self.window,g.TEXTIDS['utils'])

        ## SPRITES

        self.bgx,self.bgy = 0,250
        self.bg1dx = 0
        self.bgdx = 0

        self.sprids = {}
        self.sprids['bg-1'] = g.sman.addSpr(g.TEXTIDS['bg-1'],(self.bgx,self.bgy),'back-1')
        g.sman.modify(self.sprids['bg-1'],scale=(0.75,0.75))
        self.sprids['bg.1'] = g.sman.addSpr(g.TEXTIDS['bg'],(self.bgx,self.bgy),'back')
        g.sman.modify(self.sprids['bg.1'],scale=(0.75,0.75))
        self.sprids['bg.2'] = g.sman.addSpr(g.TEXTIDS['bg'],(self.bgx+g.sman.spr(self.sprids['bg.1']).width,self.bgy),'back')
        g.sman.modify(self.sprids['bg.2'],scale=(0.75,0.75))

        self.sprids['bg1.1'] = g.sman.addSpr(g.TEXTIDS['bg1'],(self.bgx,self.bgy),'back1')
        g.sman.modify(self.sprids['bg1.1'],scale=(1.2,1.2))
        self.sprids['bg1.2'] = g.sman.addSpr(g.TEXTIDS['bg1'],(self.bgx+g.sman.spr(self.sprids['bg1.1']).width,self.bgy),'back1')
        g.sman.modify(self.sprids['bg1.2'],scale=(1.2,1.2))
        #self.sprids['bgmid'] = g.sman.addSpr(g.TEXTIDS['bgmid'],(-1000,-50),'mid-1')
        #g.sman.modify(self.sprids['bg1.2'],scale=(1.2,1.2))

        ## sprites effects

        self.sprids['effects'] = {}
        sizes = []
        for scr in g.scr.screens:
            if (scr.width,scr.height) not in sizes:
                sizes.append((scr.width,scr.height))

        for size in sizes:
            self.sprids['effects'][size] = g.sman.addSpr(g.TEXTIDS['blur'],group='up-1',vis=False)
            g.sman.modify(self.sprids['effects'][size],scale=size,opacity=150)

        print(self.sprids['effects'])


        ## STREETS
        o2.generate_map()

        ## PERSOS

        self.perso = p.Perso(g.TEXTIDS['persos'],fill=FILL_INV)
        o2.NY.CITY['home'].set_owner(self.perso)
        #self.sprids['cred_bar'] =
        self.lab_doing = g.lman.addLab(self.perso.doing,(1880,1050),font_size=20,anchor=('right','top'))

        #p.BOTS = []
        n = 30*len(o2.NY.CITY)
        print(n,'bots in this game !')
        for i in range(n):
            street = o2.NY.rand_street()
            pos = (random.randint(0,street.rxf),random.randint(105,175))

            if random.random() < 1/8 and len(names.rappeurs) > 0:
                p.BOTS.append(p.Rappeur(g.TEXTIDS['persos'],pos,street=street.name))
            else:
                p.BOTS.append(p.Fan(g.TEXTIDS['persos'],pos,street=street.name))

        for hum in p.BOTS:
            if hum.street != 'ghost':
                o2.NY.CITY[hum.street].add_hum(hum)
            else:
                o2.NY.Ghost.add_hum(hum)

        ## cycle

        self.cycle = g.Cycle(self.perso)

        ## ZONES

        zones = []
        zones.append(o.Ordi(1990,150,self.perso))
        zones.append(o.Studio(2640,225))
        zones.append(o.Market(450,210))
        zones.append(o.Lit(-600,225))
        o2.NY.CITY['home'].assign_zones(zones)

        zones = []
        zones.append(o.Distrib(2900,225))
        street = o2.NY.rand_street().name
        o2.NY.CITY[street].assign_zones(zones)
        print('let\'s find the',street,'!')

        o2.NY.CITY[self.perso.street].load()


        ## items
        self.this_hud_caught_an_item = None

        ## END

        self.tick = 0
        self.day = 0
        self.duree_day = 60 # en secondes
        self.gameover = False

        # menu
        self.create_menu()

        # labels

        self.lab_fps = g.lman.addLab('FPS : 0',(20,1060),group='up',font_size=32,anchor=('left','top'))
        self.lab_day = g.lman.addLab('DAY : 0',(20,1060-50),group='up',font_size=32,anchor=('left','top'))
        self.lab_street = g.lman.addLab('home',(20,1060-50-32),group='up',font_size=20,anchor=('left','top'))




        # keys
        self.keys = key.KeyStateHandler()
        self.window.push_handlers(self.keys)
        self.longpress = {}
        self.cooldown = 0.5

        # clicks
        self.clicks = {'L':False,'R':False,'M':[0,0]}
        self.mouse_speed = 0

        # final
        self.action = "play" # play pause
        self.playing = True

        pyglet.clock.schedule_interval(self.gameloop,0.0000001)
        pyglet.app.run()

    def create_organise_textures(self):

        g.TEXTIDS['persos'] = g.tman.loadImSeq('perso.png',(4,6))
        g.TEXTIDS['_son'] = g.tman.loadImSeq('son.png',(1,6))
        g.TEXTIDS['_phaz'] = g.tman.loadImSeq('phaz.png',(1,6))
        g.TEXTIDS['_instru'] = g.tman.loadImSeq('instru.png',(1,6))
        g.TEXTIDS['_plum'] = g.tman.loadImSeq('plum.png',(1,6))
        g.TEXTIDS['item'] = g.tman.loadImSeq('item.png',(6,6))
        g.TEXTIDS['utils'] = g.tman.loadImSeq('utils.png',(8,8))
        #g.TEXTIDS['gui'] = g.tman.loadImSeq('gui.png',(8,8))

        qua = ['F','D','C','B','A','S']
        g.TEXTIDS['plume'] = {}
        for i in range(len(g.TEXTIDS['_plum'])):
            g.TEXTIDS['plume'][qua[i]] = g.TEXTIDS['_plum'][i]
        del g.TEXTIDS['_plum']

        g.TEXTIDS['phase'] = {}
        for i in range(len(g.TEXTIDS['_phaz'])):
            g.TEXTIDS['phase'][qua[i]] = g.TEXTIDS['_phaz'][i]
        del g.TEXTIDS['_phaz']

        g.TEXTIDS['instru'] = {}
        for i in range(len(g.TEXTIDS['_instru'])):
            g.TEXTIDS['instru'][qua[i]] = g.TEXTIDS['_instru'][i]
        del g.TEXTIDS['_instru']

        g.TEXTIDS['son'] = {}
        for i in range(len(g.TEXTIDS['_son'])):
            g.TEXTIDS['son'][qua[i]] = g.TEXTIDS['_son'][i]
        del g.TEXTIDS['_son']

        g.TEXTIDS['gui'] = g.tman.loadImSeq('gui.png',(2,2))
        g.TEXTIDS['bg-1'] = g.tman.loadIm('bg/bg-1'+'.png')
        g.TEXTIDS['bg'] = g.tman.loadIm('bg/bg'+'.png')
        g.TEXTIDS['bg1'] = g.tman.loadIm('bg/bg1'+'.png')
        g.TEXTIDS['bgmid'] = g.tman.loadIm('bg/bg2'+'.png')
        g.TEXTIDS['bgup'] = g.tman.loadIm('bg/bg3'+'.png')
        g.TEXTIDS['street1_bg'] = g.tman.loadIm('bg/street1_bg'+'.png')

        ##

        g.TEXTIDS['steam'] = g.tman.addCol(20,20,c['lightgrey'])
        g.TEXTIDS['steam2'] = g.tman.addCol(50,50,c['grey'])

        ## huds
        g.TEXTIDS['studhud'] = g.tman.loadIm('studhud.png')
        g.TEXTIDS['ordhud'] = g.tman.loadIm('ordhud.png')

        ## effects
        g.TEXTIDS['blur'] = g.tman.addCol(1,1,c['black'])

    def get_current_screen(self):

        x,y = self.window.get_location()
        for i in range(len(self.screens)):
            scr = self.screens[i]
            if (x >= scr.x and x <= scr.x + scr.width) and (y >= scr.y and y <= scr.y + scr.height):
                return scr
        return self.screens[0]

    def create_menu(self):

        self.menu = m.Menu()
        self.menu_fonct = {'play':self.change_action,'quit':self.get_out,'go home':self.perso.tp}
        self.menu_args = {'play':['play'],'go home':[0,None,o2.NY.CITY['home']]}

    def apply_menu(self,res):

        if res:
            if type(res) == type((0,1)):
                for thg in res:
                    self.apply_menu(thg)
            else:
                if res in self.menu_fonct and res in self.menu_args:
                    self.menu_fonct[res](*self.menu_args[res])
                elif res in self.menu_fonct:
                    self.menu_fonct[res]()
                else:
                    print('click',res)


    ### ONCE FUNCTIONS

    def game_over(self):

        self.label_gameover = g.lman.addLab('GAME OVER',(1920/2,1080/2),anchor=('center','center'),font_size=200,color=c['darkkhaki'],group='up')
        self.label_gameover2 = g.lman.addLab('GAME OVER',(1920/2,1080/2),anchor=('center','center'),font_size=210,color=c['black'],group='up')

        g.bertran.set_speed(0,0)

    def get_out(self):
        self.playing = False

    def change_action(self,act='play'):

        size_scr = (self.window.screen.width,self.window.screen.height)
        if act == "pause":
            g.sman.unhide(self.sprids['effects'][size_scr])
            self.menu.unhide()
            g.bertran.set_speed(0,0)
        else:
            g.sman.unhide(self.sprids['effects'][size_scr],True)
            self.menu.unhide(True)
            g.bertran.set_speed(0,1)

        self.action = act
        #print('go',act)

        #self.perso.pause(act)


    ### PYGLET FUNCTIONS

    def on_key_press(self,symbol,modifiers):

        if self.action == "play":

            self.longpress[symbol] = time.time()

            if symbol == key.ESCAPE:
                if self.perso.element_colli != None and type(self.perso.element_colli) not in [p.Human,p.Fan,p.Rappeur,p.Perso] and self.perso.element_colli.activated:
                    self.perso.element_colli.close(self.perso)
                    return pyglet.event.EVENT_HANDLED
                else:
                    self.change_action('pause')
                    if not ESK_QUIT:
                        return pyglet.event.EVENT_HANDLED
            #affiche les différents OrderedGroup d'affichage
            elif symbol == key.G:

                print('\nYOU ASKED TO PRINT GROUPS AND THEIR ORGANISATION:')
                print('  will be displayed in descending order like that : order,name\n')

                tab = []
                orders_sorted = sorted(g.gman.names_wo,reverse=True)

                for order in orders_sorted:
                    say = str(order)
                    say += (6-len(say))*' '
                    say +=g.gman.names_wo[order]
                    print(say)
                print('')

            elif symbol == key.B:
                print(self.perso.invhud)
                print(self.perso.plume)

            if self.perso.alive:

                if symbol == key.A:
                    self.perso.drop_plume()

                elif symbol == key.E:
                    if self.perso.element_colli != None:

                        if type(self.perso.element_colli) in [p.Human,p.Fan,p.Rappeur,p.Perso]:
                            if self.perso.element_colli.alive:
                                self.perso.element_colli.do('hit')
                                self.perso.be_hit(self.perso.element_colli)
                            self.perso.do('hit')
                            self.perso.element_colli.be_hit(self.perso)
                        else:
                            if not self.perso.element_colli.longpress:
                                if type(self.perso.element_colli) == o.Porte:
                                    self.perso.element_colli.activate(self.perso)
                                else:
                                    self.perso.element_colli.activate(self.perso)
                                self.perso.do('hit')
                    else:
                        self.perso.do('hit')

                elif symbol == key.X:
                    self.perso.hud.rollhide()

                elif symbol == key.I:
                    self.perso.invhud.rollhide()

                elif symbol == key.F:

                    choiced_son = None
                    for son in self.perso.invhud.inventory['son']:
                        if not son.item._released:
                            choiced_son = son.item
                            break
                    if choiced_son != None:
                        self.perso.release_son(choiced_son,p.BOTS,self.cycle.day)

        elif self.action == 'pause':

            if symbol == key.ESCAPE:
                res = self.menu.unclick()
                self.apply_menu(res)
                if not ESK_QUIT:
                    return pyglet.event.EVENT_HANDLED

            elif symbol == key.BACKSPACE:
                res = self.menu.unclick()
                self.apply_menu(res)
                return pyglet.event.EVENT_HANDLED

            elif symbol == key.ENTER:
                res = self.menu.click()
                self.apply_menu(res)

            elif symbol == key.UP:
                self.menu.up()

            elif symbol == key.DOWN:
                self.menu.down()

    def on_key_release(self,symbol,modifiers):

        if symbol in self.longpress:
            del self.longpress[symbol]

    def on_close(self):

        print('\n\nNumber of lines :',compt(self.path))
        gs.save_files(self.path)

    def on_mouse_motion(self,x,y,dx,dy):
        g.M = [x,y]

        if self.action == "play":
            ## CHECK ALL UI
            #print(self.this_hud_caught_an_item)

            # plumUI
            if self.perso.plume != None and self.perso.plumhud.ui.visible and self.this_hud_caught_an_item == None:
                self.perso.plumhud.ui.check_mouse(x,y)

            # lifeUI
            if self.perso.lifehud.ui.visible and self.this_hud_caught_an_item == None:
                self.perso.lifehud.ui.check_mouse(x,y)

            # credUI
            if self.perso.credhud.ui.visible and self.this_hud_caught_an_item == None:
                self.perso.credhud.ui.check_mouse(x,y)

            #phaseUI

            for zone in o2.NY.CITY[self.perso.street].zones:

                if zone == 'studio' and self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['studio'].hud and o2.NY.CITY[self.perso.street].zones['studio'].hud.item_caught == None:
                    self.this_hud_caught_an_item = None

                if zone == 'ordi' and self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['ordi'].hud and o2.NY.CITY[self.perso.street].zones['ordi'].hud.item_caught == None:
                    self.this_hud_caught_an_item = None

                if o2.NY.CITY[self.perso.street].zones[zone].activated:

                    if zone == 'lit':
                        if o2.NY.CITY[self.perso.street].zones['lit'].hud.ui != None :
                            if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['lit'].hud) : #check si il a caught

                                o2.NY.CITY[self.perso.street].zones['lit'].hud.ui.check_mouse(x,y)
                                if o2.NY.CITY[self.perso.street].zones['lit'].hud.ui.caught:
                                        o2.NY.CITY[self.perso.street].zones['lit'].hud.ui.move(x,y)

                    if zone == 'studio':
                        if self.this_hud_caught_an_item == None:
                            for lab in o2.NY.CITY[self.perso.street].zones['studio'].hud.uis:
                                ui = o2.NY.CITY[self.perso.street].zones['studio'].hud.uis[lab]
                                if ui != None :
                                    ui.check_mouse(x,y)

                        elif self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['studio'].hud: #check si il a caught
                            if o2.NY.CITY[self.perso.street].zones['studio'].hud.item_caught != None:
                                ui = o2.NY.CITY[self.perso.street].zones['studio'].hud.item_caught
                                ui.check_mouse(x,y)
                                if ui.caught:
                                        ui.move(x,y)

                    if zone == 'ordi':
                        if self.this_hud_caught_an_item == None:
                            for lab in o2.NY.CITY[self.perso.street].zones['ordi'].hud.uis:
                                ui = o2.NY.CITY[self.perso.street].zones['ordi'].hud.uis[lab]
                                if ui != None :
                                    ui.check_mouse(x,y)

                        elif self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['ordi'].hud: #check si il a caught
                            if o2.NY.CITY[self.perso.street].zones['ordi'].hud.item_caught != None:
                                ui = o2.NY.CITY[self.perso.street].zones['ordi'].hud.item_caught
                                ui.check_mouse(x,y)
                                if ui.caught:
                                        ui.move(x,y)

            if self.this_hud_caught_an_item == self.perso.invhud and self.perso.invhud.item_caught == None:
                self.this_hud_caught_an_item = None

            # inventUI
            if self.perso.invhud.visible:
                if self.this_hud_caught_an_item == None:
                    self.perso.invhud.check_hoover(x,y)
                elif self.this_hud_caught_an_item == self.perso.invhud:
                    for uitype in self.perso.invhud.inventory:
                        for ui in self.perso.invhud.inventory[uitype]:
                            if ui.caught:
                                ui.move(x,y)
                                ui.check_mouse(x,y)

            #print(self.this_hud_caught_an_item)

    def on_mouse_press(self,x, y, button, modifiers):

        if self.action == "play":
            letsbacktnothingcaught = False

            ## CHECK ALL UI

            # plumUI
            if self.perso.plume != None and self.perso.plumhud.ui.visible and self.this_hud_caught_an_item == None:
                self.perso.plumhud.ui.check_pressed()

            #phaseUI
            for zone in o2.NY.CITY[self.perso.street].zones:
                if o2.NY.CITY[self.perso.street].zones[zone].activated:

                    if zone == 'lit':
                        if o2.NY.CITY[self.perso.street].zones['lit'].hud.ui != None :
                            if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['lit'].hud) : #check si il peut catch

                                caught_dropped = o2.NY.CITY[self.perso.street].zones['lit'].hud.catch_or_drop(x,y,self.perso)

                                if caught_dropped == 1: # means caught
                                    self.this_hud_caught_an_item = o2.NY.CITY[self.perso.street].zones['lit'].hud
                                elif caught_dropped == -1: # means dropped
                                    letsbacktnothingcaught = True

                                self.on_mouse_motion(x,y,0,0)

                    elif zone == 'studio':
                        if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['studio'].hud) : #check si il peut catch
                            caught_dropped = o2.NY.CITY[self.perso.street].zones['studio'].hud.catch_or_drop(x,y,self.perso)

                            if caught_dropped == 1: # means caught
                                self.this_hud_caught_an_item = o2.NY.CITY[self.perso.street].zones['studio'].hud
                            elif caught_dropped == -1: # means dropped
                                letsbacktnothingcaught = True

                            #self.on_mouse_motion(x,y,0,0)

                    elif zone == 'ordi':
                        if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['ordi'].hud) : #check si il peut catch

                            if o2.NY.CITY[self.perso.street].zones['ordi'].hud.uis['main'] != None and self.perso not in o2.NY.CITY[self.perso.street].zones['ordi'].hud.uis['main'].item.owners:
                                g.Cur.start_long_press(o2.NY.CITY[self.perso.street].zones['ordi'].hud.uis['main'].box,o2.NY.CITY[self.perso.street].zones['ordi'].hud.buy_instru)


                            caught_dropped = o2.NY.CITY[self.perso.street].zones['ordi'].hud.catch_or_drop(x,y)

                            if caught_dropped == 1: # means caught
                                self.this_hud_caught_an_item = o2.NY.CITY[self.perso.street].zones['ordi'].hud
                            elif caught_dropped == -1: # means dropped
                                letsbacktnothingcaught = True

                            #self.on_mouse_motion(x,y,0,0)

            # inventUI
            if self.perso.invhud.visible:

                if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == self.perso.invhud) : #check si il peut catch
                    caught_dropped = self.perso.invhud.catch_or_drop(x,y)

                    if caught_dropped == 1: # means caught
                        self.this_hud_caught_an_item = self.perso.invhud
                    elif caught_dropped == -1: # means dropped
                        self.this_hud_caught_an_item = None

                    self.on_mouse_motion(x,y,0,0)

            if letsbacktnothingcaught:
                self.this_hud_caught_an_item = None

    def on_mouse_release(self,x,y,button,modifiers):
        g.Cur.reset()

    def on_mouse_drag(self,x, y, dx, dy, buttons, modifiers):
        self.on_mouse_motion(x,y,dx,dy)


    ### LOOP

    def events(self):

        if self.action == "play":

            if not self.gameover:

                ## moving perso
                if self.keys[key.Q]:
                    self.perso.move('L',o2.NY.CITY[self.perso.street])
                if self.keys[key.D]:
                    self.perso.move('R',o2.NY.CITY[self.perso.street])

                if self.keys[key.Z]:
                    self.perso.move('up',o2.NY.CITY[self.perso.street])
                if self.keys[key.S]:
                    self.perso.move('down',o2.NY.CITY[self.perso.street])

                ## moving freeze Corleone
                if self.perso.street == p.BOTS[0].street:
                    if self.keys[key.K]:
                        p.BOTS[0].move('L',o2.NY.CITY[self.perso.street])
                    if self.keys[key.M]:
                        p.BOTS[0].move('R',o2.NY.CITY[self.perso.street])

                if self.keys[key.E]:
                    if self.perso.element_colli != None and type(self.perso.element_colli) not in [p.Human,p.Fan,p.Rappeur,p.Perso]:
                        if self.perso.element_colli.longpress:
                            if time.time() - self.longpress[key.E] > self.cooldown:
                                self.longpress[key.E] = time.time()
                                self.perso.element_colli.activate(self.perso)
                                self.perso.do('hit')

            if self.keys[key.LEFT] or self.keys[key.RIGHT]:
                if self.keys[key.RIGHT]:
                    g.GodCam.activate('R')
                else:
                    g.GodCam.activate()
            else:
                g.GodCam.unactivate(self.perso)

    def draw(self):

        g.tman.draw()

    def refresh(self):

        #print(g.Cam.X)


        ## FPS
        dt = time.time() - self.lab_fps_time
        self.lab_fps_time = time.time()
        self.lab_fps1.append(int(1/dt))
        if len(self.lab_fps1) > 10:
            del self.lab_fps1[0]
        moyfps = int(sum(self.lab_fps1)/len(self.lab_fps1))
        g.lman.set_text(self.lab_fps,'FPS : '+str(moyfps))

        if self.action == "play":

            # STREETS
            g.lman.set_text(self.lab_street,self.perso.street)

            # DAYS
            g.lman.set_text(self.lab_day,'DAY : '+str(self.cycle.day))


            ## anchor / moving sprites

            if True:

                #--# zones elem
                for zone in o2.NY.CITY[self.perso.street].zones:
                    zone=o2.NY.CITY[self.perso.street].zones[zone]
                    x_r = zone.gex + g.Cam.X + g.GodCam.X
                    y_r = zone.gey + g.Cam.Y
                    #g.sman.modify(zone.skin_id,(x_r,y_r))
                    zone.move(x_r,y_r)

                #--# zones elem item
                for item in o2.NY.CITY[self.perso.street].items:
                    #item=o2.NY.CITY[self.perso.street].items[item]
                    x_r = item.gex + g.Cam.X + g.GodCam.X
                    y_r = item.gey + g.Cam.Y
                    #g.sman.modify(item.skin_id,(x_r,y_r))
                    item.move(x_r,y_r)

                #--# persos
                for hum in o2.NY.CITY[self.perso.street].humans + [self.perso]:
                    x_r = hum.gex + g.Cam.X + g.GodCam.X
                    y_r = hum.gey + g.Cam.Y
                    g.sman.modify(hum.skin_id,(x_r,y_r))
                    hum.update_lab()
                self.perso.check_colli(o2.NY.CITY[self.perso.street])


                #--# bg
                w = g.sman.spr(self.sprids['bg.1']).width
                x_bg1,y_bg1 = self.bgx+g.Cam.X*0.2 +self.bgdx + g.GodCam.X,g.Cam.Y*0.2 +self.bgy
                x_bg2,y_bg2 = self.bgx+g.Cam.X*0.2 +w +self.bgdx+ g.GodCam.X,g.Cam.Y*0.2 +self.bgy

                if x_bg1 >= 0:
                    self.bgdx -= w
                elif x_bg2 + w <= 1920:
                    self.bgdx += w

                g.sman.modify(self.sprids['bg.1'],(x_bg1,y_bg1))
                g.sman.modify(self.sprids['bg.2'],(x_bg2,y_bg2))

                #bg1
                w = g.sman.spr(self.sprids['bg1.1']).width
                x_bg1,y_bg1 = self.bgx+g.Cam.X*0.4 +self.bg1dx + g.GodCam.X,g.Cam.Y*0.4 +self.bgy
                x_bg2,y_bg2 = self.bgx+g.Cam.X*0.4 +w +self.bg1dx+ g.GodCam.X,g.Cam.Y*0.4 +self.bgy

                if x_bg1 >= 0:
                    self.bg1dx -= w
                elif x_bg2 + w <= 1920:
                    self.bg1dx += w

                g.sman.modify(self.sprids['bg1.1'],(x_bg1,y_bg1))
                g.sman.modify(self.sprids['bg1.2'],(x_bg2,y_bg2))
                o2.NY.CITY[self.perso.street].modify(g.Cam.X+ g.GodCam.X,g.Cam.Y)
                #g.sman.modify(self.sprids['bgmid'],(g.Cam.X-1000,-50+g.Cam.Y))

                g.Cam.update(self.perso.realbox,o2.NY.CITY[self.perso.street])

            if g.bertran.speed > 0:

                ## particles
                g.pman.modify('icons',dy=0.1)
                g.pman.modify('dmg',dy=0.1,dx=g.Cam.dx + g.GodCam.X)

                ## fans are streaming
                for i in range(len(self.perso.disco)):
                    chance = random.randint(0,int(60*moyfps))
                    malus = 1-i*0.2
                    if chance < self.perso.nb_fans*malus:
                        random.choice(p.BOTS).stream(self.perso.disco[i])


            ## perso

            for hum in o2.NY.CITY[self.perso.street].humans + [self.perso]:
                hum.check_do()
            g.lman.set_text(self.lab_doing,self.perso.doing)
            self.perso.hud.update()
            #print(self.perso.gex,self.perso.gey)

            if self.perso.money <= 0 or not self.perso.alive:
                #print('game over')
                self.gameover = True
                self.game_over()

    def gameloop(self,dt):

        if self.playing:
            if self.tick == 0:

                self.lab_fps_time = time.time()
                self.lab_fps1 = []

            self.tick += 1
            #print(self.tick)

            # EVENTS
            self.events()

            gl.glClearColor(1/4,1/4,1/4,1)
            # CLR
            self.window.clear()

            # RFRSH
            self.refresh()

            # DRW
            self.draw()

        else:
            print('\n\nNumber of lines :',compt(self.path))
            gs.save_files(self.path)

            self.window.close()

def main():

    app = App()
    app.init()

if __name__ == '__main__':
    main()



 _newfile_ :Z:\DESKTOP\CODING\plumegang/./test.py



def a(qua):

    basis = (qua)*10
    bonus = 0

    if qua > 0.6:
        bonus += (qua-0.6)*15
    if qua > 0.8:
        bonus += (qua-0.8)*50
    if qua > 0.92:
        bonus += (qua-0.92)*200
    if qua > 0.98:
        bonus += (qua-0.98)*800
    if qua > 0.995:
        bonus += (qua-0.995)*8400

    return int((basis + bonus)*10)

def test2():

    for i in range(20):

        qua = i/20

        b = a(qua)
        print(qua,b)
        #x = (qua-self.qua_score) * self.nb_fans

    for i in range(90,99,2):

        qua = i/100

        b = a(qua)
        print(qua,b)

    for i in range(990,1001,1):

        qua = i/1000

        b = a(qua)
        print(qua,b)

import src.obj2 as o2

o2.generate_map()
o2.draw_lines()



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/colors.py



### colors
c = {

"air" : (0,0,0,0),
"aliceblue" : (240, 248, 255,255),
"antiquewhite" : (250, 235, 215,255),
"aqua" : (0, 255, 255,255),
"aquamarine" : (127, 255, 212,255),
"azure" : (240, 255, 255,255),
"beige" : (245, 245, 220,255),
"bisque" : (255, 228, 196,255),
"black" : (0, 0, 0,255),
"blanchedalmond" : (255, 235, 205,255),
"blue" : (0, 0, 255,255),
"blueviolet" : (138, 43, 226,255),
"brown" : (165, 42, 42,255),
"burlywood" : (222, 184, 135,255),
"cadetblue" : (95, 158, 160,255),
"chartreuse" : (127, 255, 0,255),
"chocolate" : (210, 105, 30,255),
"coral" : (255, 127, 80,255),
"cornflowerblue" : (100, 149, 237,255),
"cornsilk" : (255, 248, 220,255),
"crimson" : (220, 20, 60,255),
"cyan" : (0, 255, 255,255),
"darkblue" : (0, 0, 139,255),
"darkcyan" : (0, 139, 139,255),
"darkgoldenrod" : (184, 134, 11,255),
"darkgray" : (169, 169, 169,255),
"darkgrey" : (169, 169, 169,255),
"darkgreen" : (0, 100, 0,255),
"darkkhaki" : (189, 183, 107,255),
"darkmagenta" : (139, 0, 139,255),
"darkolivegreen" : (85, 107, 47,255),
"darkorange" : (255, 140, 0,255),
"darkorchid" : (153, 50, 204,255),
"darkred" : (139, 0, 0,255),
"darksalmon" : (233, 150, 122,255),
"darkseagreen" : (143, 188, 143,255),
"darkslateblue" : (72, 61, 139,255),
"darkslategray" : (47, 79, 79,255),
"darkslategrey" : (47, 79, 79,255),
"darkturquoise" : (0, 206, 209,255),
"darkviolet" : (148, 0, 211,255),
"deeppink" : (255, 20, 147,255),
"deepskyblue" : (0, 191, 255,255),
"dimgray" : (105, 105, 105,255),
"dimgrey" : (105, 105, 105,255),
"dodgerblue" : (30, 144, 255,255),
"firebrick" : (178, 34, 34,255),
"floralwhite" : (255, 250, 240,255),
"forestgreen" : (34, 139, 34,255),
"fuchsia" : (255, 0, 255,255),
"gainsboro" : (220, 220, 220,255),
"ghostwhite" : (248, 248, 255,255),
"gold" : (255, 215, 0,255),
"goldenrod" : (218, 165, 32,255),
"gray" : (128, 128, 128,255),
"grey" : (128, 128, 128,255),
"green" : (0, 128, 0,255),
"greenyellow" : (173, 255, 47,255),
"honeydew" : (240, 255, 240,255),
"hotpink" : (255, 105, 180,255),
"indianred" : (205, 92, 92,255),
"indigo" : (75, 0, 130,255),
"ivory" : (255, 255, 240,255),
"khaki" : (240, 230, 140,255),
"lavender" : (230, 230, 250,255),
"lavenderblush" : (255, 240, 245,255),
"lawngreen" : (124, 252, 0,255),
"lemonchiffon" : (255, 250, 205,255),
"lightblue" : (173, 216, 230,255),
"lightred" : (235, 98, 85,255),
"lightcoral" : (240, 128, 128,255),
"lightcyan" : (224, 255, 255,255),
"lightgoldenrodyellow" : (250, 250, 210,255),
"lightgray" : (211, 211, 211,255),
"lightgrey" : (211, 211, 211,255),
"lightgreen" : (144, 238, 144,255),
"lightpink" : (255, 182, 193,255),
"lightsalmon" : (255, 160, 122,255),
"lightseagreen" : (32, 178, 170,255),
"lightskyblue" : (135, 206, 250,255),
"lightslategray" : (119, 136, 153,255),
"lightslategrey" : (119, 136, 153,255),
"lightsteelblue" : (176, 196, 222,255),
"lightyellow" : (255, 255, 224,255),
"lime" : (0, 255, 0,255),
"limegreen" : (50, 205, 50,255),
"linen" : (250, 240, 230,255),
"magenta" : (255, 0, 255,255),
"maroon" : (128, 0, 0,255),
"mediumaquamarine" : (102, 205, 170,255),
"mediumblue" : (0, 0, 205,255),
"mediumorchid" : (186, 85, 211,255),
"mediumpurple" : (147, 112, 219,255),
"mediumseagreen" : (60, 179, 113,255),
"mediumslateblue" : (123, 104, 238,255),
"mediumspringgreen" : (0, 250, 154,255),
"mediumturquoise" : (72, 209, 204,255),
"mediumvioletred" : (199, 21, 133,255),
"midnightblue" : (25, 25, 112,255),
"mintcream" : (245, 255, 250,255),
"mistyrose" : (255, 228, 225,255),
"moccasin" : (255, 228, 181,255),
"navajowhite" : (255, 222, 173,255),
"navy" : (0, 0, 128,255),
"oldlace" : (253, 245, 230,255),
"olive" : (128, 128, 0,255),
"olivedrab" : (107, 142, 35,255),
"orange" : (255, 165, 0,255),
"orangered" : (255, 69, 0,255),
"orchid" : (218, 112, 214,255),
"palegoldenrod" : (238, 232, 170,255),
"palegreen" : (152, 251, 152,255),
"paleturquoise" : (175, 238, 238,255),
"palevioletred" : (219, 112, 147,255),
"papayawhip" : (255, 239, 213,255),
"peachpuff" : (255, 218, 185,255),
"peru" : (205, 133, 63,255),
"pink" : (255, 192, 203,255),
"plum" : (221, 160, 221,255),
"powderblue" : (176, 224, 230,255),
"purple" : (128, 0, 128,255),
"red" : (255, 0, 0,255),
"rosybrown" : (188, 143, 143,255),
"royalblue" : (65, 105, 225,255),
"saddlebrown" : (139, 69, 19,255),
"salmon" : (250, 128, 114,255),
"sandybrown" : (244, 164, 96,255),
"seagreen" : (46, 139, 87,255),
"seashell" : (255, 245, 238,255),
"sienna" : (160, 82, 45,255),
"silver" : (192, 192, 192,255),
"skyblue" : (135, 206, 235,255),
"slateblue" : (106, 90, 205,255),
"slategray" : (112, 128, 144,255),
"slategrey" : (112, 128, 144,255),
"snow" : (255, 250, 250,255),
"springgreen" : (0, 255, 127,255),
"steelblue" : (70, 130, 180,255),
"tan" : (210, 180, 140,255),
"teal" : (0, 128, 128,255),
"thistle" : (216, 191, 216,255),
"tomato" : (255, 99, 71,255),
"turquoise" : (64, 224, 208,255),
"violet" : (238, 130, 238,255),
"wheat" : (245, 222, 179,255),
"white" : (255, 255, 255,255),
"whitesmoke" : (245, 245, 245,255),
"yellow" : (255, 255, 0,255),
"yellowgreen" : (154, 205, 50,255),

#my colors

"delta_blue" : (150, 150, 200,255),
"delta_lightblue" : (175, 175, 225,255),
"delta_purple" : (102, 102, 153,255),
"F" : (255,255,255,255),
"D" : (100, 200, 255,255),
"C" : (156, 204, 101,255),
"B" : (255, 112, 67,255),
"A" : (255, 202, 40,255),
"S" : (209, 196, 233,255),
"X" : (0, 0, 0,255),

}



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/getsave.py


"""""
CODED by deltasfer
enjoy
programme sauvegarde de fichiers sources
"""""

# va de pair avec getback v3

version = 3

import os

def save_files(bigpath,path = ['/.','/src'],save_path = '/autosav/'):

    autosav = ''

    for chem in path:
        #print('path',bigpath+chem,':',os.listdir(bigpath+chem))
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    autosav += '\n\n\n _newfile_ :' + bigpath+chem+'/'+file + '\n\n\n'
                    with open(bigpath+chem+'/'+file,'r') as f:
                        autosav += f.read()
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
        version[1]+=1
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])
    except:
        os.makedirs(bigpath+save_path)
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

    with open(bigpath+save_path+'saved_'+version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]+'.savd','w') as f:
        f.write(autosav)

    print('files saved, version',version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

def get_version(bigpath,save_path = '/autosav/'):
    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
    except:
        a=0
    return version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/graphic.py


"""
CODED by deltasfer
enjoy
"""



import pyglet
import src.utils as u

"""""""""""""""""""""""""""""""""""
 PART ONE : GRAPHIC STUFF
"""""""""""""""""""""""""""""""""""

class ScreenManager():
    def __init__(self):

        self.display = pyglet.canvas.get_display()
        self.screens = self.display.get_screens()

    def _screen(self):
        return self.screens[0]
    screen = property(_screen)

    def _size(self):
        return self.screen.width,self.screen.height
    size = property(_size)

    def _w(self):
        return self.screen.width
    w = property(_w)

scr = ScreenManager()

#manager who rules groups to draw things in the right order u know
class GroupManager():

    def __init__(self):


        self.groups = {} ## give the group with the name

        self.names_wo = {} ## give the name with the order
        self.orders = {} ## give the order with the name

        names = ['back-2','back-1','back','back1','mid-1','mid','mid1','front','perso-1','hud-1','hud','hud1','perso','midup','hud2-1','hud2','ui-2','ui-1','ui','up-1','up']
        self.distance_btw = 8

        for i in range(len(names)):
            self.addGroup(names[i],i*self.distance_btw)

    def getGroup(self,name):
        if name not in self.groups:
            print('aie ce groupe n\'existe pas')
            return None
        else:
            return self.groups[name]

    def addGroup(self,name,order):
        if not name in self.groups:
            self.groups[name] = pyglet.graphics.OrderedGroup(order)
            self.orders[name] = order
            self.names_wo[order] = name
            return self.groups[name]
        return self.groups[name] # group was already created

#manager who init images
class TextureManager():

    def __init__(self,path='.'):

        self.textures = {}

        self.path = path

        self.ids = []

        self.batch = pyglet.graphics.Batch()

    def loadImSeq(self,path2,size):

        # size décrit le nb de tiles en w et en h

        path3 = '/item/'
        img = pyglet.image.load(self.path+path3+path2)
        textures = pyglet.image.ImageGrid(img, *size)

        ids = []
        for txt in textures:
            id = u.get_id('text')
            self.textures[id] = txt

            self.ids.append(id)
            ids.append(id)
        return ids

    def loadIm(self,path2):

        path3 = '/item/'
        id = u.get_id('img')
        img = pyglet.image.load(self.path+path3+path2)
        self.textures[id] = img
        self.ids.append(id)
        return id

    def addCol(self,w,h,color=(255,255,255,255)):

        pattern = pyglet.image.SolidColorImagePattern(color)
        id = u.get_id('col')
        self.textures[id] = pattern.create_image(w,h)
        self.ids.append(id)
        return id

    def draw(self):
        self.batch.draw()

tman,gman = TextureManager(),GroupManager()

#manager who rules normal sprites
class SpriteManager():

    def __init__(self):

        ## SPRITES

        self.sprites = {}

        self.ids = []

    def addSpr(self,textid,xy_pos=(0,0),group=None,alr_id=-1,vis=True):

        if alr_id == -1:
            id = u.get_id('spr')
            self.ids.append(id)
        else:
            id =alr_id


        self.sprites[id] = pyglet.sprite.Sprite(tman.textures[textid], batch=tman.batch)
        self.sprites[id].position = xy_pos
        self.sprites[id].visible = vis

        if group != None:
            self.addToGroup(id,group)

        return id

    def addCol(self,col=(255,255,255,255),box=u.box(),group=None,alr_id=-1,vis=True):
        text = tman.addCol(*box.wh,col)
        return self.addSpr(text,box.xy,group,alr_id,vis)

    def addToGroup(self,id,group_name='back'):

        group = gman.getGroup(group_name)
        self.sprites[id].group = group

        #self.detect()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                if self.sprites[id].visible != (not hide):
                    self.sprites[id].visible = (not hide)

        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)

        else:
            if self.sprites[tabids].visible != (not hide):
                self.sprites[tabids].visible = (not hide)

    def set_text(self,sprid,textid):
        if self.sprites[sprid].image != tman.textures[textid]:
            self.sprites[sprid].image = tman.textures[textid]

    def modify(self,sprid,pos=None,scale=None,group=None,opacity=None):

        # position
        x,y = None,None
        if pos != None and pos != (self.sprites[sprid].x,self.sprites[sprid].y):
            x,y = pos

        # scale
        scalex,scaley = None,None
        if scale != None and scale != (self.sprites[sprid].scale_x,self.sprites[sprid].scale_y):
            scalex,scaley = scale

        # updating group
        if group != None:
            group = gman.getGroup(group)
            if group != self.sprites[sprid].group:
                self.sprites[sprid].group = group


        # updating opacity
        if opacity != None:
            if opacity != self.sprites[sprid].opacity:
                self.sprites[sprid].opacity = opacity

        # final updating positon and scale
        self.sprites[sprid].update(x=x,y=y,scale_x = scalex,scale_y=scaley)

    def filter(self,sprid,color=(255,0,0)):
        self.sprites[sprid].color = color

    def spr(self,id):
        if id in self.sprites:
            return self.sprites[id]
        return None

    def box(self,id):
        spr = self.sprites[id]
        return [spr.x,spr.y,spr.x+spr.width,spr.y+spr.height]

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les sprites affichés ingame
            for id in self.sprites:
                self.sprites[id].delete()
            self.sprites = {}
            #print('sprites deleted')

        elif type(tabids) == type('aa'): # on delete un seul sprite precis
            if tabids in self.sprites:
                self.sprites[tabids].delete()
                del self.sprites[tabids]
                #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de sprite
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de sprite
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

#manager who rules normal labels
class LabelManager():

    def __init__(self,font=None):

        if font != None:
            self.font = font
        else:
            self.font = 'arial'

        self.labels = {}
        self.ids = []

    def updateman(self,font=None):

        if font != None:
            self.font = font
        else:
            self.font = 'arial'

    def addLab(self,contenu,xy_pos=(0,0),alr_id=-1,vis=True,font_name=None,font_size=30,group='hud',anchor = ('left','bottom'),color=(255,255,255,255)):

        if alr_id == -1:
            id = u.get_id('lbl')
            self.ids.append(id)
        else:
            id =alr_id

        if not font_name:
            font_name = self.font

        if type(contenu) != type('qsd'):
            contenu = str(contenu)

        multi = '\n' in contenu

        anchor_x,anchor_y= anchor

        if multi:
            maxwidth=0
            lines = contenu.split('\n')
            for line in lines:
                lab = pyglet.text.Label(line,font_name=font_name,font_size=font_size, \
                                anchor_x= anchor_x,anchor_y= anchor_y,color=color)
                maxwidth = max(maxwidth,lab.content_width)
                lab.delete()
            width = maxwidth+1

        else:
            width = None


        if group != None:
            group = gman.getGroup(group)
        self.labels[id] = pyglet.text.Label(contenu,font_name=font_name,font_size=font_size,group=group, \
                        batch=tman.batch,anchor_x= anchor_x,anchor_y= anchor_y,color=color,multiline=multi,width=width)



        self.labels[id].x,self.labels[id].y = xy_pos
        self.unhide(id,not vis)
        #self.labels[id].visible = vis


        return id

    def addToGroup(self,id,thg=['back',None],thg2=0,level_to_put_in=0):

        group = gman.createGroup(thg,thg2,level_to_put_in)
        #print('GROUP IS',group)
        self.labels[id]._init_groups(group)
        self.labels[id]._update()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                self.unhide(id,hide)
        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)
        else:
            if hide == False and self.labels[tabids].color[3] == 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],255]
            elif hide == True and self.labels[tabids].color[3] != 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],0]

    def set_text(self,lblid,contenu):

        if type(contenu) != type('qsdd'):
            contenu = str(contenu)

        if self.labels[lblid].text != contenu:
            self.labels[lblid].text = contenu

    def printGroup(self,lblid):
        print('\ttopgroup :',self.labels[lblid].top_group)
        print('\tbackgroup :',self.labels[lblid].background_group)
        print('\tforegroup :',self.labels[lblid].foreground_group)
        print('\tforegroupdeco :',self.labels[lblid].foreground_decoration_group)

    def modify(self,lblid,pos=None,size=None,scale=None,color=None):

        if scale != None and scale != (self.labels[lblid].scale_x,self.labels[lblid].scale_y):
            self.labels[lblid].update(scale_x = scale[0],scale_y=scale[1])
            #self.labels[lblid].scale_x,self.labels[lblid].scale_y = scale

        if size != None:
            self.labels[lblid].font_size = size

        if pos != None:
            if pos[0] != None and pos[0] != self.labels[lblid].x:
                self.labels[lblid].x = pos[0]
            if pos[1] != None and pos[1] != self.labels[lblid].y:
                self.labels[lblid].y = pos[1]

        if color != None and color != self.labels[lblid].color:
            self.labels[lblid].color = color

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les labels affichés ingame
            for id in self.labels:
                self.labels[id].delete()
            self.labels = {}
            #print('labels deleted')

        elif type(tabids) == type('aa'): # on delete un seul label precis
            self.labels[tabids].delete()
            del self.labels[tabids]
            #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de label
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de label
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

sman,lman = SpriteManager(),LabelManager()

class ParticleManager():

    def __init__(self):
        self.sprites = {}
        self.sprites['normal'] = {}
        self.sprites['steam'] = {}
        self.sprites['steam2'] = {}

        self.labels = {}
        self.labels['normal'] = {}
        self.labels['icons'] = {}
        self.labels['dmg'] = {}

    def addPart(self,textid,xy_pos=(0,0),duree=5,group=None,key='normal',opac=255,vis=True):

        id = u.get_id('spr_part')
        #self.ids.append(id)

        self.sprites[key][id] = pyglet.sprite.Sprite(tman.textures[textid], batch=tman.batch,visible=vis)
        self.sprites[key][id].position = xy_pos
        self.sprites[key][id].opacity = opac

        if group != None:
            group = gman.getGroup(group)
            self.sprites[key][id].group = group

        bertran.schedule_once(self.delay_spr,duree*0.01,id,key)

    def addLabPart(self,contenu,xy_pos=(0,0),duree=5,font_name=None,font_size=20,group=None,anchor = \
                ('center','center'),color=(255,255,255,255),key='normal',vis=True):

        id = u.get_id('lab_part')

        if not font_name:
            font_name = lman.font

        if not vis:
            color = [*color[:3],0]

        if type(contenu) != type('qsd'):
            contenu = str(contenu)

        anchor_x,anchor_y= anchor

        if group != None:
            group = gman.getGroup(group)
        self.labels[key][id] = pyglet.text.Label(contenu,font_name=font_name,font_size=font_size,group=group, \
                        batch=tman.batch,anchor_x= anchor_x,anchor_y= anchor_y,color=color)

        self.labels[key][id].x,self.labels[key][id].y = xy_pos

        bertran.schedule_once(self.delay_lab,duree*0.01,id,key)

    def addCol(self,col=(255,255,255,255),box=u.box(),duree=5,group=None,key='normal'):
        text = tman.addCol(*box.wh,col)
        self.addPart(text,box.xy,duree,group,key)

    def delay_spr(self,dt,id,key):

        #print(id)
        self.sprites[key][id].opacity = self.sprites[key][id].opacity-(0.1*255)
        if self.sprites[key][id].opacity <= 0:
            self.sprites[key][id].delete()
            del self.sprites[key][id]
        else:
            bertran.schedule_once(self.delay_spr,dt,id,key)

    def delay_lab(self,dt,id,key):

        self.labels[key][id].color = (*self.labels[key][id].color[:3]  , int(self.labels[key][id].color[3]-(0.1*255)))
        if self.labels[key][id].color[3] <= 0:
            self.labels[key][id].delete()
            del self.labels[key][id]
        else:
            bertran.schedule_once(self.delay_lab,dt,id,key)

    def modify(self,key,dx=0,dy=0,setx=None,sety=None):
        if key in self.sprites:
            for id in self.sprites[key]:
                if setx == None:
                    self.sprites[key][id].x += dx
                else:
                    self.sprites[key][id].x = setx
                if sety == None:
                    self.sprites[key][id].y += dy
                else:
                    self.sprites[key][id].y = sety
        else:
            for id in self.labels[key]:
                if setx == None:
                    self.labels[key][id].x += dx
                else:
                    self.labels[key][id].x = setx
                if sety == None:
                    self.labels[key][id].y += dy
                else:
                    self.labels[key][id].y = sety

    def unhide(self,key,hide=False):
        if key in self.sprites:
            for id in self.sprites[key]:
                if self.sprites[key][id].visible != (not hide):
                    self.sprites[key][id].visible = (not hide)
        else:
            for id in self.labels[key]:
                if hide == False and self.labels[key][id].color[3] == 0:
                    self.labels[key][id].color = [*self.labels[key][id].color[:3],255]
                elif hide == True and self.labels[key][id].color[3] != 0:
                    self.labels[key][id].color = [*self.labels[key][id].color[:3],0]


pman = ParticleManager()

TEXTIDS = {}


"""""""""""""""""""""""""""""""""""
 PART TWO : CCCC STUFF
"""""""""""""""""""""""""""""""""""


#### CYCLE -> rules day/night cycle
class Cycle():

    def __init__(self,perso):

        # general

        self.len = 10 # longueur du cycle en secondes
        self.dt = 1 # dt avant chaque update

        self.tick = 0

        self.day = 1 # nb de jour

        self.perso = perso

        # sprites

        """self.sprids = {}
        self.sprids['sun'] ="""



        self.ticked()

    def ticked(self,dt=0):

        self.tick += 1
        #print(self.tick)
        if self.tick*self.dt > self.day*self.len:
            self.day += 1
            #print('wow new day')
            self.perso.add_money(-10)
        day_percentage = (self.tick*self.dt - (self.day-1)*self.len )/self.len
        #print(day_percentage)

        bertran.schedule_once(self.ticked,self.dt)

    def update(self,day_percentage):
        pass

M = [0,0]

#### CLOCK

class Clock(pyglet.clock.Clock):

    def __init__(self):
        self.__time = 0
        self.speed = 1.0
        pyglet.clock.Clock.__init__(self, time_function=self.get_time)
        pyglet.clock.schedule(self.advance)

    def advance(self, time):
        self.__time += time * self.speed
        self.tick()

    def get_time(self):
        return self.__time

    def set_speed(self, dt=0, speed=1.0):
        self.speed = speed

bertran = Clock() # bertran c'est le S


#### CURSOR

class Cursor():

    def __init__(self):

        self.long_time = 0.5 #en secondes

        ##
        self.longbox = None
        self.start_time = None
        self.func = None

    def init(self,window,textures):

        self.window = window
        self.text = textures

        cursor = pyglet.window.ImageMouseCursor(tman.textures[self.text[1]],16,16)
        self.window.set_mouse_cursor(cursor)

    def start_long_press(self,box,func):

        if u.collisionAX(box.realbox,M) and self.start_time == None:

            self.longbox = box
            self.start_time = bertran.get_time()
            self.func = func

            #self.check_long_press(0,xy)
            bertran.schedule(self.check_long_press)

    def check_long_press(self,dt=0):

        #check si on a quitté le box:
        if not u.collisionAX(self.longbox.realbox,M):
            self.reset()
            return 0

        percentage = (bertran.get_time()-self.start_time)/self.long_time
        self.change_skin(percentage)
        #print(percentage)

        if percentage >= 1:
            print('applying',self.func.__name__)
            self.func() # on clique
            self.reset()

    def reset(self):
        bertran.unschedule(self.check_long_press)
        cursor = pyglet.window.ImageMouseCursor(tman.textures[self.text[1]],16,16)
        self.window.set_mouse_cursor(cursor)
        self.longbox = None
        self.start_time = None
        self.func = None

    def change_skin(self,per):
        nb = int(per*8)
        cursor = pyglet.window.ImageMouseCursor(tman.textures[self.text[nb+8]],16,16)
        self.window.set_mouse_cursor(cursor)

Cur = Cursor()

#### CAMERA

SPEED = 20

class Camera():

    def __init__(self):

        self._X,self._Y = 0,0
        #self.BGX,self.BGY = 0,0
        self._dx,self._dy = 0,0

        self.d = 0.2

        self.speed = SPEED

        self.activate = True

    def update(self,persobox,street):

        if self.activate:
            #scr = (1920,1080)
            #scr = scr.size
            moved = [False,False]

            x,xf = street.xxf
            #print(x,xf)

            #X
            if persobox[2] > 4*scr.size[0]/5 and (xf == None or street.rxf > scr.size[0] +self.speed):
                self.lessx()
                moved[0] = True

            elif persobox[0] < scr.size[0]/5 and (x == None or street.x < -self.speed):
                self.morex()
                moved[0] = True

            if xf != None and street.rxf < scr.size[0]:
                self.morex()
                moved[0] = True
            elif x != None and street.x > 0:
                self.lessx()
                moved[0] = True

            #print(street.x,street.rxf)

            #Y
            if persobox[3] > 19*scr.size[1]/20:
                self.lessy()
                moved[1] = True
            elif persobox[1] < scr.size[1]/20:
                self.morey()
                moved[1] = True

            #moved
            if not moved[0]:
                self._dx = 0
            if not moved[1]:
                self._dy = 0

    def tp(self,ge_x,real_x):

        ## ge_x -> position générale du perso après passage par la porte
        ## real_x -> position réelle à l'écran du perso AVANT passage par la porte

        self._X = - ge_x + real_x

    ##

    def morex(self):
        self._X += self.speed
        self._dx = self.speed
        #self.BGX = self._X*self.d
    def morey(self):
        self._Y += self.speed
        self._dy = self.speed
        #self.BGY = self._Y*self.d
    def lessx(self):
        self._X -= self.speed
        self._dx = -self.speed
        #self.BGX = self._X*self.d
    def lessy(self):
        self._Y -= self.speed
        self._dy = -self.speed
        #self.BGY = self._Y*self.d


    ##

    def _setX(self,X):
        if X != self._X:
            self._dx = self._X-X
            self._X = X
            #self.BGX = self.d*X
    def _X(self):
        return self._X
    def _setY(self,Y):
        if Y != self._Y:
            self._dy = self._Y-Y
            self._Y = Y
            #self.BGY = self.d*Y
    def _Y(self):
        return self._Y
    X = property(_X,_setX)
    Y = property(_Y,_setY)

    def _dx(self):
        return self._dx
    def _dy(self):
        return self._dy
    dx = property(_dx)
    dy = property(_dy)

Cam = Camera()

class GodCamera():

    def __init__(self):

        self._X,self._Y = 0,0
        self._dx,self._dy = 0,0

        #self.d = 0.2

        self.speed = 30

    def activate(self,dir='L'):

        if dir == 'L':
            self.X += self.speed
        else:
            self.X -= self.speed

        Cam.activate = False

    def unactivate(self,perso):

        if not Cam.activate:
            self.X,self.Y = 0,0
            Cam.tp(perso.gex,scr.w/2)
            Cam.activate = True

    ###

    def _setX(self,X):
        if X != self._X:
            self._dx = self._X-X
            self._X = X
            #self.BGX = self.d*X
    def _X(self):
        return self._X
    def _setY(self,Y):
        if Y != self._Y:
            self._dy = self._Y-Y
            self._Y = Y
            #self.BGY = self.d*Y
    def _Y(self):
        return self._Y
    X = property(_X,_setX)
    Y = property(_Y,_setY)

    def _dx(self):
        return self._dx
    def _dy(self):
        return self._dy
    dx = property(_dx)
    dy = property(_dy)

GodCam = GodCamera()



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/menu.py


"""
CODED by deltasfer
enjoy
"""

from src import graphic as g
from src.colors import *
from collections import OrderedDict

class Menu:

    def __init__(self):

        self.arb = OrderedDict()

        self.arb['play']='play'
        self.arb['go home']='go home','play'
        param = OrderedDict()
        param['cheh'] = None
        param['lezgo'] = None
        self.arb['param'] = param
        self.arb['quit'] = 'quit'

        self.max_len = 4

        """
            play

            param
                cheh
                lezgo

            quit
        """


        self.point = '' ## exemple : "param,screen,opac"
        self.cursor = 0


        ## labels

        self.labids = {}
        (w,h) = g.scr.size
        padding = 100
        self.size = 30
        x = w/2
        y = h/2 + (self.max_len*self.size + (self.max_len-1)*padding)/2
        for i in range(self.max_len):
            y = y-padding
            self.labids[i] = g.lman.addLab('',(x,y),font_size=self.size,group='up',vis=False,anchor=('center','center'))

        self.actualise()

    def actualise(self):

        cont = list(self.get_dic().keys())

        vis = g.lman.labels[self.labids[0]].color[3]
        #print(list(c["yellow"])[:3],vis)

        g.lman.unhide(self.labids,True)
        for i in range(len(cont)):
            g.lman.set_text(self.labids[i],cont[i])
            if self.cursor == i:
                g.lman.modify(self.labids[i],size=50,color=list(c["yellow"])[:3]+[vis])
            else:
                g.lman.modify(self.labids[i],size=self.size,color=list(c["white"])[:3]+[vis])


    ##

    def click(self):

        if type(list(self.get_dic().values())[self.cursor]) == type(self.arb):
            name_dic = list(self.get_dic().keys())[self.cursor]
            if self.point == '':
                self.point = name_dic
            else:
                self.point = self.point+','+name_dic
            self.cursor = 0
            #print('waoouh',name_dic,self.point,self.cursor)
            self.actualise()
            return name_dic
        else:
            return list(self.get_dic().values())[self.cursor]

    def unclick(self):
        if self.point == '':
            return 'play'
        else:
            self.point = ','.join(self.point.split(',')[:-1])
            print(self.point)
            self.cursor = 0
            self.actualise()

    def up(self):
        self.cursor -= 1
        if self.cursor < 0:
            self.cursor = self.get_current_maxcurs()-1
        self.actualise()

    def down(self):
        self.cursor += 1
        if self.cursor >= self.get_current_maxcurs():
            self.cursor = 0
        self.actualise()

    ##

    def get_dic(self):
        depth = 0
        if self.point != '':
            path = self.point.split(',')
            depth = len(path)

        dic = self.arb
        for i in range(depth):
            dic = dic[path[i]]
        return dic

    def get_current_maxcurs(self):
        return len(self.get_dic())

    def unhide(self,hide=False):
        ## unhide() AFFICHE le menu
        ## unhide(True) N'AFFICHE PAS le menu

        g.lman.unhide(self.labids,hide)



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/names.py


