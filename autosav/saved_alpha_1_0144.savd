


 _newfile_ :Z:\DESKTOP\CODING\plumegang/./plume.py




import pyglet,time
from pyglet.window import key
import pyglet.gl as gl

from src.utils import *
import src.getsave as gs
from src import obj as o
from src import graphic as g

CURRENT_PATH = os.path.dirname(os.path.abspath(__file__)) # fopatouché
if ' ' in CURRENT_PATH:
    print('Le chemin d\'acces contient un espace. Le programme va BUGUER SA MERE.')
    print('Changez le programme de place pour un path sans espace svp.')



class App():

    ### INIT FUNCTIONS

    def __init__(self):

        self.path = CURRENT_PATH

        ### windows

        self.window = pyglet.window.Window()

        self.window.set_fullscreen()

        self.window.push_handlers(self)

        ### loading fonts
        font_path = 'item/fonts/'
        self.fonts = ['RaubFont']
        self.font = ['RaubFont']
        for ft in self.fonts:
            try:
                pyglet.resource.add_font(font_path+ft+'.otf')
            except:
                try:
                    pyglet.resource.add_font(font_path+ft+'.ttf')
                except :
                    pyglet.resource.add_font('arial.ttf')

        ### managers

        #g.init_managers(CURRENT_PATH,self.font)

        g.lman.updateman(self.font[0])

        #self.cmd = graphic.CmdManager((20 , self.size_fullscr[1] - 50))
        #self.specMan = graphic.SpecialManager(g.tman,self.current_size_scr)

        #self.aff_cmd = False

    def init(self):

        ## SPRITES / TEXTURES

        g.TEXTIDS['persos'] = g.tman.loadImSeq('perso.png',(1,4))
        g.TEXTIDS['son'] = g.tman.loadImSeq('son.png',(1,6))
        g.TEXTIDS['phaz'] = g.tman.loadImSeq('phaz.png',(1,6))
        g.TEXTIDS['instru'] = g.tman.loadImSeq('instru.png',(1,6))
        g.TEXTIDS['plum'] = g.tman.loadImSeq('plum.png',(1,6))

        qua = ['F','D','C','B','A','S']
        g.TEXTIDS['plume'] = {}
        for i in range(len(g.TEXTIDS['plum'])):
            g.TEXTIDS['plume'][qua[i]] = g.TEXTIDS['plum'][i]
        del g.TEXTIDS['plum']

        g.TEXTIDS['gui'] = g.tman.loadImSeq('gui.png',(2,2))
        g.TEXTIDS['bg'] = g.tman.loadIm('bg/bg'+str(random.randint(1,8))+'.png')


        self.sprids = {}
        self.sprids['bg'] = g.sman.addSpr(g.TEXTIDS['bg'],(0,250),'back')
        g.sman.modify(self.sprids['bg'],scale=(1.5,1.5))

        ## PERSOS

        self.perso = o.Rappeur(g.TEXTIDS['persos'])
        #self.sprids['cred_bar'] =

        ## ZONES

        o.ZONES['ELEM']['ordi'] = o.Zone_ELEM(box(1400,225,200,200),'ordi','red')
        o.ZONES['ELEM']['plume'] = o.Market(box(600,225,200,200))


        ## END

        # keys
        self.keys = key.KeyStateHandler()
        self.window.push_handlers(self.keys)
        self.longpress = {}
        self.cooldown = 0.5

        # clicks
        self.clicks = {'L':False,'R':False,'M':[0,0]}
        self.mouse_speed = 0


        self.playing = True

        pyglet.clock.schedule_interval(self.gameloop,0.0000001)
        pyglet.app.run()


    ### ONCE FUNCTIONS

    def get_out(self):
        self.playing = False


    ### PYGLET FUNCTIONS

    def on_key_press(self,symbol,modifiers):

        self.longpress[symbol] = time.time()

        if symbol == key.ESCAPE:
            pass

        #affiche les différents OrderedGroup d'affichage
        elif symbol == key.G:

            print('\nYOU ASKED TO PRINT GROUPS AND THEIR ORGANISATION:')
            print('  will be displayed in descending order like that : order,name\n')

            tab = []
            orders_sorted = sorted(g.gman.names_wo,reverse=True)

            for order in orders_sorted:
                say = str(order)
                say += (6-len(say))*' '
                say +=g.gman.names_wo[order]
                print(say)
            print('')

        elif symbol == key.E:
            if self.perso.element_colli != None:
                if not self.perso.element_colli.longpress:
                    self.perso.element_colli.activate(self.perso)
            else:
                self.perso.hit()

    def on_key_release(self,symbol,modifiers):

        if symbol in self.longpress:
            del self.longpress[symbol]

    def on_close(self):

        print('\n\nNumber of lines :',compt(self.path))
        gs.save_files(self.path)

    ### LOOP

    def events(self):

        if self.keys[key.Q]:
            self.perso.move('L')
        if self.keys[key.D]:
            self.perso.move('R')

        if self.keys[key.E]:
            if self.perso.element_colli != None:
                if self.perso.element_colli.longpress:
                    if time.time() - self.longpress[key.E] > self.cooldown:
                        self.longpress[key.E] = time.time()
                        self.perso.element_colli.activate(self.perso)


    def draw(self):

        g.tman.draw()

    def refresh(self):

        ## perso

        self.perso.check_ani()

    def gameloop(self,dt):

        if self.playing:

            # EVENTS
            self.events()

            gl.glClearColor(1/4,1/4,1/4,1)
            # CLR
            self.window.clear()

            # RFRSH
            self.refresh()

            # DRW
            self.draw()

        else:
            print('\n\nNumber of lines :',compt(self.path))
            gs.save_files(self.path)

            self.window.close()


def main():

    app = App()
    app.init()

if __name__ == '__main__':
    main()



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/colors.py



### colors
c = {

"air" : (0,0,0,0),
"aliceblue" : (240, 248, 255,255),
"antiquewhite" : (250, 235, 215,255),
"aqua" : (0, 255, 255,255),
"aquamarine" : (127, 255, 212,255),
"azure" : (240, 255, 255,255),
"beige" : (245, 245, 220,255),
"bisque" : (255, 228, 196,255),
"black" : (0, 0, 0,255),
"blanchedalmond" : (255, 235, 205,255),
"blue" : (0, 0, 255,255),
"blueviolet" : (138, 43, 226,255),
"brown" : (165, 42, 42,255),
"burlywood" : (222, 184, 135,255),
"cadetblue" : (95, 158, 160,255),
"chartreuse" : (127, 255, 0,255),
"chocolate" : (210, 105, 30,255),
"coral" : (255, 127, 80,255),
"cornflowerblue" : (100, 149, 237,255),
"cornsilk" : (255, 248, 220,255),
"crimson" : (220, 20, 60,255),
"cyan" : (0, 255, 255,255),
"darkblue" : (0, 0, 139,255),
"darkcyan" : (0, 139, 139,255),
"darkgoldenrod" : (184, 134, 11,255),
"darkgray" : (169, 169, 169,255),
"darkgrey" : (169, 169, 169,255),
"darkgreen" : (0, 100, 0,255),
"darkkhaki" : (189, 183, 107,255),
"darkmagenta" : (139, 0, 139,255),
"darkolivegreen" : (85, 107, 47,255),
"darkorange" : (255, 140, 0,255),
"darkorchid" : (153, 50, 204,255),
"darkred" : (139, 0, 0,255),
"darksalmon" : (233, 150, 122,255),
"darkseagreen" : (143, 188, 143,255),
"darkslateblue" : (72, 61, 139,255),
"darkslategray" : (47, 79, 79,255),
"darkslategrey" : (47, 79, 79,255),
"darkturquoise" : (0, 206, 209,255),
"darkviolet" : (148, 0, 211,255),
"deeppink" : (255, 20, 147,255),
"deepskyblue" : (0, 191, 255,255),
"dimgray" : (105, 105, 105,255),
"dimgrey" : (105, 105, 105,255),
"dodgerblue" : (30, 144, 255,255),
"firebrick" : (178, 34, 34,255),
"floralwhite" : (255, 250, 240,255),
"forestgreen" : (34, 139, 34,255),
"fuchsia" : (255, 0, 255,255),
"gainsboro" : (220, 220, 220,255),
"ghostwhite" : (248, 248, 255,255),
"gold" : (255, 215, 0,255),
"goldenrod" : (218, 165, 32,255),
"gray" : (128, 128, 128,255),
"grey" : (128, 128, 128,255),
"green" : (0, 128, 0,255),
"greenyellow" : (173, 255, 47,255),
"honeydew" : (240, 255, 240,255),
"hotpink" : (255, 105, 180,255),
"indianred" : (205, 92, 92,255),
"indigo" : (75, 0, 130,255),
"ivory" : (255, 255, 240,255),
"khaki" : (240, 230, 140,255),
"lavender" : (230, 230, 250,255),
"lavenderblush" : (255, 240, 245,255),
"lawngreen" : (124, 252, 0,255),
"lemonchiffon" : (255, 250, 205,255),
"lightblue" : (173, 216, 230,255),
"lightcoral" : (240, 128, 128,255),
"lightcyan" : (224, 255, 255,255),
"lightgoldenrodyellow" : (250, 250, 210,255),
"lightgray" : (211, 211, 211,255),
"lightgrey" : (211, 211, 211,255),
"lightgreen" : (144, 238, 144,255),
"lightpink" : (255, 182, 193,255),
"lightsalmon" : (255, 160, 122,255),
"lightseagreen" : (32, 178, 170,255),
"lightskyblue" : (135, 206, 250,255),
"lightslategray" : (119, 136, 153,255),
"lightslategrey" : (119, 136, 153,255),
"lightsteelblue" : (176, 196, 222,255),
"lightyellow" : (255, 255, 224,255),
"lime" : (0, 255, 0,255),
"limegreen" : (50, 205, 50,255),
"linen" : (250, 240, 230,255),
"magenta" : (255, 0, 255,255),
"maroon" : (128, 0, 0,255),
"mediumaquamarine" : (102, 205, 170,255),
"mediumblue" : (0, 0, 205,255),
"mediumorchid" : (186, 85, 211,255),
"mediumpurple" : (147, 112, 219,255),
"mediumseagreen" : (60, 179, 113,255),
"mediumslateblue" : (123, 104, 238,255),
"mediumspringgreen" : (0, 250, 154,255),
"mediumturquoise" : (72, 209, 204,255),
"mediumvioletred" : (199, 21, 133,255),
"midnightblue" : (25, 25, 112,255),
"mintcream" : (245, 255, 250,255),
"mistyrose" : (255, 228, 225,255),
"moccasin" : (255, 228, 181,255),
"navajowhite" : (255, 222, 173,255),
"navy" : (0, 0, 128,255),
"oldlace" : (253, 245, 230,255),
"olive" : (128, 128, 0,255),
"olivedrab" : (107, 142, 35,255),
"orange" : (255, 165, 0,255),
"orangered" : (255, 69, 0,255),
"orchid" : (218, 112, 214,255),
"palegoldenrod" : (238, 232, 170,255),
"palegreen" : (152, 251, 152,255),
"paleturquoise" : (175, 238, 238,255),
"palevioletred" : (219, 112, 147,255),
"papayawhip" : (255, 239, 213,255),
"peachpuff" : (255, 218, 185,255),
"peru" : (205, 133, 63,255),
"pink" : (255, 192, 203,255),
"plum" : (221, 160, 221,255),
"powderblue" : (176, 224, 230,255),
"purple" : (128, 0, 128,255),
"red" : (255, 0, 0,255),
"rosybrown" : (188, 143, 143,255),
"royalblue" : (65, 105, 225,255),
"saddlebrown" : (139, 69, 19,255),
"salmon" : (250, 128, 114,255),
"sandybrown" : (244, 164, 96,255),
"seagreen" : (46, 139, 87,255),
"seashell" : (255, 245, 238,255),
"sienna" : (160, 82, 45,255),
"silver" : (192, 192, 192,255),
"skyblue" : (135, 206, 235,255),
"slateblue" : (106, 90, 205,255),
"slategray" : (112, 128, 144,255),
"slategrey" : (112, 128, 144,255),
"snow" : (255, 250, 250,255),
"springgreen" : (0, 255, 127,255),
"steelblue" : (70, 130, 180,255),
"tan" : (210, 180, 140,255),
"teal" : (0, 128, 128,255),
"thistle" : (216, 191, 216,255),
"tomato" : (255, 99, 71,255),
"turquoise" : (64, 224, 208,255),
"violet" : (238, 130, 238,255),
"wheat" : (245, 222, 179,255),
"white" : (255, 255, 255,255),
"whitesmoke" : (245, 245, 245,255),
"yellow" : (255, 255, 0,255),
"yellowgreen" : (154, 205, 50,255),

}



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/getsave.py


"""""
programme sauvegarde de fichiers sources
"""""

# va de pair avec getback v3

version = 3

import os

def save_files(bigpath,path = ['/.','/src'],save_path = '/autosav/'):

    autosav = ''

    for chem in path:
        #print('path',bigpath+chem,':',os.listdir(bigpath+chem))
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    autosav += '\n\n\n _newfile_ :' + bigpath+chem+'/'+file + '\n\n\n'
                    with open(bigpath+chem+'/'+file,'r') as f:
                        autosav += f.read()
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
        version[1]+=1
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])
    except:
        os.makedirs(bigpath+save_path)
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

    with open(bigpath+save_path+'saved_'+version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]+'.savd','w') as f:
        f.write(autosav)

    print('files saved, version',version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

def get_version(bigpath,save_path = '/autosav/'):
    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
    except:
        a=0
    return version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/graphic.py






import pyglet
import src.utils as utils



#manager who rules groups to draw things in the right order u know
class GroupManager():

    def __init__(self):


        self.groups = {} ## give the group with the name

        self.names_wo = {} ## give the name with the order
        self.orders = {} ## give the order with the name

        names = ['back','mid','front','hud','map','up']
        self.distance_btw = 8

        for i in range(len(names)):
            self.addGroup(names[i],i*self.distance_btw)

    def getGroup(self,name):
        if name not in self.groups:
            print('aie ce groupe n\'existe pas')
            return None
        else:
            return self.groups[name]

    def addGroup(self,name,order):
        if not name in self.groups:
            self.groups[name] = pyglet.graphics.OrderedGroup(order)
            self.orders[name] = order
            self.names_wo[order] = name
            return self.groups[name]
        return self.groups[name] # group was already created

#manager who init images
class TextureManager():

    def __init__(self,path='.'):

        self.textures = {}

        self.path = path

        self.ids = []

        self.batch = pyglet.graphics.Batch()

    def loadImSeq(self,path2,size):

        # size décrit le nb de tiles en w et en h

        path3 = '/item/'
        img = pyglet.image.load(self.path+path3+path2)
        textures = pyglet.image.ImageGrid(img, *size)

        ids = []
        for txt in textures:
            id = utils.get_id('text')
            self.textures[id] = txt

            self.ids.append(id)
            ids.append(id)
        return ids

    def loadIm(self,path2):

        path3 = '/item/'
        id = utils.get_id('img')
        img = pyglet.image.load(self.path+path3+path2)
        self.textures[id] = img
        self.ids.append(id)
        return id

    def addCol(self,w,h,color=(255,255,255,255)):

        pattern = pyglet.image.SolidColorImagePattern(color)
        id = utils.get_id('col')
        self.textures[id] = pattern.create_image(w,h)
        self.ids.append(id)
        return id

    def draw(self):
        self.batch.draw()

tman,gman = TextureManager(),GroupManager()

#manager who rules normal sprites
class SpriteManager():

    def __init__(self):

        ## SPRITES

        self.sprites = {}

        self.ids = []

    def addSpr(self,textid,xy_pos=(0,0),group=None,alr_id=-1,vis=True):

        if alr_id == -1:
            id = utils.get_id('spr')
            self.ids.append(id)
        else:
            id =alr_id


        self.sprites[id] = pyglet.sprite.Sprite(tman.textures[textid], batch=tman.batch)
        self.sprites[id].position = xy_pos
        self.sprites[id].visible = vis

        if group != None:
            self.addToGroup(id,group)

        return id

    def addToGroup(self,id,group_name='back'):

        group = gman.getGroup(group_name)
        self.sprites[id].group = group

        #self.detect()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                if self.sprites[id].visible != (not hide):
                    self.sprites[id].visible = (not hide)

        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)

        else:
            if self.sprites[tabids].visible != (not hide):
                self.sprites[tabids].visible = (not hide)

    def set_text(self,sprid,textid):
        if self.sprites[sprid].image != tman.textures[textid]:
            self.sprites[sprid].image = tman.textures[textid]

    def modify(self,sprid,pos=None,scale=None,group=None):

        # position
        x,y = None,None
        if pos != None and pos != (self.sprites[sprid].x,self.sprites[sprid].y):
            x,y = pos

        # scale
        scalex,scaley = None,None
        if scale != None and scale != (self.sprites[sprid].scale_x,self.sprites[sprid].scale_y):
            scalex,scaley = scale

        # updating group
        if group != None:
            group = gman.getGroup(group)
            if group != self.sprites[sprid].group:
                self.sprites[sprid].group = group

        # final updating positon and scale
        self.sprites[sprid].update(x=x,y=y,scale_x = scalex,scale_y=scaley)

    def spr(self,id):
        if id in self.sprites:
            return self.sprites[id]
        return None

    def box(self,id):
        spr = self.sprites[id]
        return [spr.x,spr.y,spr.x+spr.width,spr.y+spr.height]

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les sprites affichés ingame
            for id in self.sprites:
                self.sprites[id].delete()
            self.sprites = {}
            #print('sprites deleted')

        elif type(tabids) == type('aa'): # on delete un seul sprite precis
            if tabids in self.sprites:
                self.sprites[tabids].delete()
                del self.sprites[tabids]
                #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de sprite
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de sprite
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

    def detect(self):

        errorsS = []
        errorsV = []
        for id in self.sprites:
            if type(self.sprites[id]) != pyglet.sprite.Sprite:
                errorsS.append(id)
            else:
                if self.sprites[id]._vertex_list == None:
                    errorsV.append(id)
        if errorsS != []:
            print('noSprite',errorsS)
        if errorsV != []:
            print('noVertex',errorsV)

#manager who rules normal labels
class LabelManager():

    def __init__(self,font=None):

        if font != None:
            self.font = font
        else:
            self.font = 'arial'

        self.labels = {}
        self.ids = []

    def updateman(self,font=None):

        if font != None:
            self.font = font
        else:
            self.font = 'arial'

    def addLabel(self,contenu,xy_pos=(0,0),alr_id=-1,vis=True,font_name=None,font_size=30,group=None,anchor = ('left','bottom'),color=(255,255,255,255)):

        if alr_id == -1:
            id = utils.get_id('lbl')
            self.ids.append(id)
        else:
            id =alr_id

        if not font_name:
            font_name = self.font


        anchor_x,anchor_y= anchor

        #group = gman.createGroup(['hud'])
        self.labels[id] = pyglet.text.Label(contenu,font_name=font_name,font_size=font_size,group=group, \
                        batch=tman.batch,anchor_x= anchor_x,anchor_y= anchor_y,color=color)
        self.labels[id].x,self.labels[id].y = xy_pos
        self.unhide(id,not vis)
        #self.labels[id].visible = vis

        return id

    def addToGroup(self,id,thg=['back',None],thg2=0,level_to_put_in=0):

        group = gman.createGroup(thg,thg2,level_to_put_in)
        #print('GROUP IS',group)
        self.labels[id]._init_groups(group)
        self.labels[id]._update()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                self.unhide(id,hide)
        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)
        else:
            if hide == False and self.labels[tabids].color[3] == 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],255]
            elif hide == True and self.labels[tabids].color[3] != 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],0]

    def set_text(self,lblid,contenu):
        if self.labels[lblid].text != contenu:
            self.labels[lblid].text = contenu

    def printGroup(self,lblid):
        print('\ttopgroup :',self.labels[lblid].top_group)
        print('\tbackgroup :',self.labels[lblid].background_group)
        print('\tforegroup :',self.labels[lblid].foreground_group)
        print('\tforegroupdeco :',self.labels[lblid].foreground_decoration_group)

    def modify(self,lblid,pos=None,scale=None):

        if scale != None and scale != (self.labels[lblid].scale_x,self.labels[lblid].scale_y):
            self.labels[lblid].update(scale_x = scale[0],scale_y=scale[1])
            #self.labels[lblid].scale_x,self.labels[lblid].scale_y = scale

        if pos != None and pos != (self.labels[lblid].x,self.labels[lblid].y):
            self.labels[lblid].x,self.labels[lblid].y = pos

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les labels affichés ingame
            for id in self.labels:
                self.labels[id].delete()
            self.labels = {}
            #print('labels deleted')

        elif type(tabids) == type('aa'): # on delete un seul label precis
            self.labels[tabids].delete()
            del self.labels[tabids]
            #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de label
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de label
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

sman,lman = SpriteManager(),LabelManager()

TEXTIDS = {}



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/obj.py



import random as r
import json,time
from src.colors import *
from src.utils import *
from src import graphic as g

"""""""""""""""""""""""""""""""""""
 INIT
"""""""""""""""""""""""""""""""""""

QUALITIES = ['F'
            ,'D-','D','D+'
            ,'C-','C','C+'
            ,'B-','B','B+'
            ,'A-','A','A+'
            ,'S-','S','S+'
            ,'S*']
QUALITIES_coeff = [0.1
            ,0.2,0.3,0.4
            ,0.5,0.6,0.7
            ,0.75,0.8,0.85
            ,0.9,0.92,0.94
            ,0.96,0.98,0.995
            ,1.1]
QUALITIES_up = {'F':0.1
            ,'D-':0.1,'D':0.1,'D+':0.1
            ,'C-':0.1,'C':0.1,'C+':0.1
            ,'B-':0.05,'B':0.05,'B+':0.05
            ,'A-':0.05,'A':0.02,'A+':0.02
            ,'S-':0.02,'S':0.02,'S+':0.015
            ,'S*':1}
QUALITIES_dwn = {'F':-1,'D-':-0.1
            ,'D':-0.1,'D+':-0.1,'C-':-0.1
            ,'C':-0.1,'C+':-0.1,'B-':-0.1
            ,'B':-0.05,'B+':-0.05,'A-':-0.05
            ,'A':-0.05,'A+':-0.02,'S-':-0.02
            ,'S':-0.02,'S+':-0.02,'S*':-0.015}

CRED = ['pire merde de la terre','sous-merde','merde'
        ,'victime','neutre','thug'
        ,'gangster','gros ganster','ennemi number one']
CRED_coeff = [-95,-80,-50,-10,10,50,80,95,101]

with open('src/mots.json','r') as f:
    MOTS = json.load(f)

THEMES = ['amour','argent','liberté','révolte','egotrip','ovni','famille','mort + dévastation','notoriété','chill','rap']

"""""""""""""""""""""""""""""""""""
 CLASSES BASIK
"""""""""""""""""""""""""""""""""""


#------# phases

class Rappeur():

    def __init__(self,textids,pos=(200,200),name='Delta'):

        # general

        self.name = name
        self.speed = 12

        #self.street_score = 0

        #self.money = 1000

        #self.nb_fans = 0
        #self.fans = []

        self.plume = rplum()

        self.element_colli = None

        # track of time

        self.time_ani_delay = 0.15
        self.time_last_ani = 0
        self.time_last_move = 0

        # skins
        self.textids = { 'R0':textids[0] , 'R1':textids[1] , 'L0':textids[2] , 'L1':textids[3] }
        self.roll_skin = 0
        self.skin_id = g.sman.addSpr(self.textids['R0'])
        g.sman.modify(self.skin_id,pos,group='up')

        # labels
        self.label_name_id = g.lman.addLabel(self.name,(40,40))

    def rplum(self):
        self.plume.rplum()

    def update_skin(self,dir='R'):

        if time.time()-self.time_last_ani > self.time_ani_delay:
            self.time_last_ani = time.time()
            g.sman.set_text(self.skin_id,self.textids[dir+str(self.roll_skin)])
            if self.roll_skin:
                self.roll_skin = 0
            else:
                self.roll_skin = 1

    def move(self,dir):

        moved = False
        x,y = g.sman.spr(self.skin_id).position
        if dir == 'R':
            g.sman.modify(self.skin_id,(x+self.speed,y))
            moved = True
        elif dir == 'L':
            g.sman.modify(self.skin_id,(x-self.speed,y))
            moved = True

        if moved :
            self.check_colli()
            self.update_skin(dir)

            self.time_last_move = time.time()

    def check_colli(self):

        boxper = g.sman.box(self.skin_id)
        colli_elem = None
        for elem in ZONES['ELEM']:
            if collision(boxper,ZONES['ELEM'][elem].box()) :
                    colli_elem = ZONES['ELEM'][elem]

        if self.element_colli != None:
            if colli_elem != None:
                if colli_elem != self.element_colli :
                    self.element_colli.unhoover()
                    self.element_colli = colli_elem
                    self.element_colli.hoover()
            else:
                self.element_colli.unhoover()
                self.element_colli = None
        else:
            if colli_elem != None:
                self.element_colli = colli_elem
                self.element_colli.hoover()

        #print(self.element_colli)

    def check_ani(self):

        if time.time()-self.time_last_move > 2*self.time_ani_delay:
            self.roll_skin = 0
            self.update_skin('R')


    def hit(self):
        print(self.name,'hits the void')


class Plume():

    def __init__(self,qua,cred):

        self.quality = qua
        self.cred_power = cred

        self.level = 0

        # skins
        self.skin_id = g.sman.addSpr(g.TEXTIDS['plume'][convert_quality(self.quality)[0]],(1500,40),'up')
        g.sman.modify(self.skin_id,scale=(0.4,0.4))

        # labels
        self.lbl_qua_id = g.lman.addLabel(convert_quality(self.quality)+' '+trunc(self.quality),(1600,60))
        self.lbl_cred_id = g.lman.addLabel(convert_streetcred(self.cred_power)+' '+str(self.cred_power),(1500,10),font_size=20)

    def rplum(self):

        self.quality = r.random()
        self.cred_power = r.randint(-100,100)
        self.update_skin()

    def update_skin(self):

        g.sman.set_text(self.skin_id,g.TEXTIDS['plume'][convert_quality(self.quality)[0]])
        g.lman.set_text(self.lbl_qua_id,convert_quality(self.quality)+' '+trunc(self.quality))
        g.lman.set_text(self.lbl_cred_id,convert_streetcred(self.cred_power)+' '+str(self.cred_power))

    def drop_phase(self):

        x = 2
        qua = (self.quality*x + r.random())/(x+1)

        x = 3
        cred = (self.cred_power*x + r.randint(-100,100))/(x+1)

        phase = Phase(qua,cred)
        #print(phase.content)
        #print(convert_quality(qua),convert_streetcred(cred))

        return phase

class Phase():

        def __init__(self,quality,cred,):

            self.quality = quality
            self.cred = cred

            self.content = self.generate_content()

            self.them = r.choice(THEMES)

        def generate_content(self):

            nb = r.randint(3,6)
            s = r.choice(MOTS)
            for i in range(nb-1):
                s += ' ' + r.choice(MOTS)
            return s

#------# instrus

class Btmaker():

    def __init__(self,qua=0.5,name='Bokusan'):

        self.name = name

        #self.money = 1000

        self.quality = qua

    def drop_instru(self):

        x = 2
        qua = (self.quality*x + r.random())/(x+1)

        instru = Instru(qua,self.name)
        #print('instru '+convert_quality(qua))
        return instru

class Instru():

    def __init__(self,qua,author):

        self.quality = qua
        self.author = author

#------# sons

class Son():

    def __init__(self,instru,phases,name='cheh'):

        self.name = name

        self.instru = instru
        self.phases = phases

        self.quality = self.global_qua()
        self.cred = max([ x.cred for x in self.phases])

        print(convert_quality(self.quality),convert_streetcred(self.cred))

    def global_qua(self):

        x_instru = 1
        x_phases = 1

        qua_instru = self.instru.quality

        qua_phases = 0
        themes = []
        for ph in self.phases:
            qua_phases += ph.quality
            if ph.them not in themes:
                themes.append(ph.them)
        qua_phases/=len(self.phases)

        qua = (x_instru*qua_instru + x_phases*qua_phases)/(x_instru+x_phases)

        if len(themes) <= 1:
            qua = upgrade_qua(qua,1)
        elif len(themes) > 2:
            qua = upgrade_qua(qua,-1)

        return qua


"""""""""""""""""""""""""""""""""""
 CLASSES GRAFIK
"""""""""""""""""""""""""""""""""""

class Zone():

    def __init__(self,box,textid='white',group='mid'):

        if textid[:4] == 'text':
            self.text_id = textid
        else:
            self.text_id = g.tman.addCol(*box.wh,c[textid])
        self.skin_id = g.sman.addSpr(self.text_id,box.xy,group)

    def box(self):
        return g.sman.box(self.skin_id)

#------# ui

class Zone_UI(Zone):

    ## HOOVER WITH MOVEMENT OF MOUSE

    def __init__(self,box,name='thing',textid='white',group='mid'):
        super(Zone_UI,self).__init__(box,textid,group)

        self.name = name

        # label
        pos = box.x + box.w/2 , box.y + box.h + 20
        self.label = g.lman.addLabel(self.name,pos,vis=False,anchor = ('center','bottom'),font_size=20,color=c['darkkhaki'])

    def hoover(self):
        g.lman.unhide(self.label)

    def unhoover(self):
        g.lman.unhide(self.label,True)

    def activate(self):
        print(self.skin_id,'activated')

#------# elements

class Zone_ELEM(Zone):

    ## HOOVER WITH MOVEMENT OF PERSO

    def __init__(self,box,name='thing',textid='white',group='mid',long=False):
        super(Zone_ELEM,self).__init__(box,textid,group)

        self.name = name
        self.longpress = long

        # label
        pos = box.x + box.w/2 , box.y + box.h + 20
        self.label = g.lman.addLabel(self.name,pos,vis=False,anchor = ('center','bottom'),font_size=20)

    def hoover(self):
        g.lman.unhide(self.label)

    def unhoover(self):
        g.lman.unhide(self.label,True)

    def activate(self,perso):
        print(perso.name,'just activated',self.name)

class Market(Zone_ELEM):

    def __init__(self,box):
        super(Market,self).__init__(box,'market','pink','mid',long=True)

    def activate(self,perso):
        print(perso.name,'just activated',self.name)
        perso.rplum()


ZONES = {}
ZONES['UI'] = {}
ZONES['ELEM'] = {}
# use ZONES['UI'] for gui
# use ZONES['ELEM'] for graphic element


"""""""""""""""""""""""""""""""""""
 USEFUL FUNCTIONS
"""""""""""""""""""""""""""""""""""

def test():

    quality = r.random()
    cred_power = r.randint(-100,100)

    print(convert_quality(quality),convert_streetcred(cred_power))

    plum = Plume(quality,cred_power)
    print('\n')
    for i in range(20):
        phaz = []
        for i in range(4):
            phaz.append(plum.drop_phase())
        btmker = Btmaker(r.random())
        Son(btmker.drop_instru(),phaz)

    #return Plume(quality,cred_power)

def rplum():

    quality = r.random()
    cred_power = r.randint(-100,100)

    #print(convert_quality(quality),convert_streetcred(cred_power))

    return Plume(quality,cred_power)

def convert_quality(qua,test=(QUALITIES,QUALITIES_coeff)):


    if qua < test[1][0]:
        return test[0][0]
    else:
        return convert_quality(qua,(test[0][1:],test[1][1:]))

def convert_streetcred(cred,test=(CRED,CRED_coeff)):

    if cred < test[1][0]:
        return test[0][0]
    else:
        return convert_streetcred(cred,(test[0][1:],test[1][1:]))

def upgrade_qua(qua,bonus=True):

    if bonus:
        return qua + QUALITIES_up[convert_quality(qua)]
    else:
        return qua + QUALITIES_dwn[convert_quality(qua)]



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/utils.py






import random,os,ctypes,time
from ctypes import windll, Structure, c_long, byref
from math import *
#from win32gui import GetWindowRect, GetForegroundWindow, GetWindowText


class POINT(Structure):
    _fields_ = [("x", c_long), ("y", c_long)]

class box():

    def __init__(self,x=0,y=0,w=30,h=30):

        self.w = w
        self.h = h
        self.x = x
        self.y = y

    def _wh(self):
        return self.w,self.h

    def _xy(self):
        return self.x,self.y

    def _xywh(self):
        return self.x,self.y,self.w,self.h

    wh = property(_wh)
    xy = property(_xy)
    xywh = property(_xywh)

## partie SCREEN

def get_screen_size():
    user32 = ctypes.windll.user32
    return user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)


## partie random

def choice(thg):

    if type(thg) == type({}):
        return choice(list(thg.keys()))
        #print(thg.keys())
    else:
        return random.choice(thg)

def randmultint(n,a,b=None): #returns n differents numbers between a and b-1

    if b == None:
        return randmultint(n,0,a-1)
    else:
        t = []
        while len(t) < n:
            new = random.randint(a,b-1)
            while new in t:
                new = random.randint(a,b-1)
            t.append(new)
        return t


def get_key_from_value(d,v,s=[]): # v valeur seule, d dic ou tab

    if type(d) == type({}):
        for key,val in d.items():
            if type(val) != type({}) and type(val) != type([]):
                if v == val:
                    return s+[key]
            else:
                ns = get_key_from_value(val,v,s+[key])
                if ns != None:
                    return ns

    elif type(d) == type([]):
        for key in range(len(d)):
            val = d[key]
            if type(val) != type({}) and type(val) != type([]):
                #print(val)
                if v == val:
                    return s+[key]
            else:
                ns = get_key_from_value(val,v,s+[key])
                if ns != None:
                    return ns

    return None

def getMousePos():
    pt = POINT()
    windll.user32.GetCursorPos(byref(pt))
    return pt.x,pt.y

def module(x,y):
    return sqrt(x**2+y**2)

def int_rd(dec):
    if dec < int(dec)+0.5:
        return int(dec)
    else:
        return ceil(dec)

def sign(n):
    if n==0:
        return 0
    else:
        return n//abs(n)

def rangef(a,b,d=1):

    res = []
    if b > a:
        while b>a:
            res.append(a)
            a+=d
    else:
        while abs(b-a)>0:
            res.append(a)
            a+=d

    return res

ids = 1112

def get_id(key):

    global ids

    id = ''+key
    id+=str(ids)
    ids+=1
    return id

def mycopy(thg):

    if type(thg) == type([]):

        res = []

        for i in thg:
            res.append(mycopy(i))

        return res

    else:

        return thg

def trunc(f, n=3):
    '''Truncates/pads a float f to n decimal places without rounding'''
    s = '{}'.format(f)
    if 'e' in s or 'E' in s:
        return '{0:.{1}f}'.format(f, n)
    i, p, d = s.partition('.')
    return '.'.join([i, (d+'0'*n)[:n]])

### PARTIE AUTO-SAUVEGARDE
def compt(bigpath,path = ['/.','/src']):

    long = 0

    for chem in path:
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    with open(bigpath+chem+'/'+file,'r') as f:
                        long += len(f.readlines())
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    return long


# collision
def collision(a,b):
    if (a[0] > b[2]) or (a[2] < b[0]) or (a[1] > b[3]) or (a[3] < b[1]):
        return False #  oklm c'est bon ca collisionne PAS
    else:
        return True # aoutch ca collisionne
