


 _newfile_ :Z:\DESKTOP\CODING\plumegang/./plume.py




import pyglet,time
from pyglet.window import key
import pyglet.gl as gl

from src.utils import *
import src.getsave as gs
from src import obj
from src import graphic as g

CURRENT_PATH = os.path.dirname(os.path.abspath(__file__)) # fopatouché
if ' ' in CURRENT_PATH:
    print('Le chemin d\'acces contient un espace. Le programme va BUGUER SA MERE.')
    print('Changez le programme de place pour un path sans espace svp.')




class App():


    ### INIT FUNCTIONS

    def __init__(self):

        self.path = CURRENT_PATH

        ### windows

        self.window = pyglet.window.Window()

        self.window.set_fullscreen()

        self.window.push_handlers(self)

        ### loading fonts
        font_path = 'item/fonts/'
        self.fonts = ['RaubFont']
        self.font = ['RaubFont']
        for ft in self.fonts:
            try:
                pyglet.resource.add_font(font_path+ft+'.otf')
            except:
                try:
                    pyglet.resource.add_font(font_path+ft+'.ttf')
                except :
                    pyglet.resource.add_font('arial.ttf')

        ### managers

        #g.init_managers(CURRENT_PATH,self.font)

        g.lman.updateman(self.font[0])

        #self.cmd = graphic.CmdManager((20 , self.size_fullscr[1] - 50))
        #self.specMan = graphic.SpecialManager(g.tman,self.current_size_scr)

        #self.aff_cmd = False

    def init(self):

        ## SPRITES / TEXTURES

        self.textids = {}

        self.textids['persos'] = g.tman.loadImSeq('perso.png',(3,9))
        self.textids['son'] = g.tman.loadImSeq('son.png',(1,6))
        self.textids['phaz'] = g.tman.loadImSeq('phaz.png',(1,6))
        self.textids['instru'] = g.tman.loadImSeq('instru.png',(1,6))
        self.textids['plum'] = g.tman.loadImSeq('plum.png',(1,6))

        qua = ['F','D','C','B','A','S']
        self.textids['plume'] = {}
        for i in range(len(self.textids['plum'])):
            self.textids['plume'][qua[i]] = self.textids['plum'][i]
        del self.textids['plum']

        self.textids['gui'] = g.tman.loadImSeq('gui.png',(2,2))
        self.textids['bg'] = g.tman.loadIm('bg/bg'+str(random.randint(1,8))+'.png')


        self.sprids = {}
        self.sprids['bg'] = g.sman.addSpr(self.textids['bg'],(0,250))
        g.sman.modify(self.sprids['bg'],scale=(1.5,1.5))
        g.sman.addToGroup(self.sprids['bg'],['back'])

        ## PERSOS

        self.perso = obj.Rappeur(self.textids['persos'][0],self.textids['plume'])
        #self.sprids['cred_bar'] =


        ## END

        # keys
        self.keys = key.KeyStateHandler()
        self.window.push_handlers(self.keys)
        self.longpress = {}
        self.cooldown = 0.5

        # clicks
        self.clicks = {'L':False,'R':False,'M':[0,0]}
        self.mouse_speed = 0


        self.playing = True

        pyglet.clock.schedule_interval(self.gameloop,0.0000001)
        pyglet.app.run()


    ### ONCE FUNCTIONS

    def get_out(self):
        self.playing = False


    ### PYGLET FUNCTIONS

    def on_key_press(self,symbol,modifiers):

        self.longpress[symbol] = time.time()

        if symbol == key.ESCAPE:
            print('wesh')

        #affiche les différents OrderedGroup d'affichage
        elif symbol == key.G:

            print('\nYOU ASKED TO PRINT GROUPS AND THEIR ORGANISATION:')
            print('  will be displayed in descending order like that : order,name\n')

            tab = []
            orders_sorted = sorted(g.gman.names_wo,reverse=True)

            for order in orders_sorted:
                say = str(order)
                say += (6-len(say))*' '
                say +=g.gman.names_wo[order]
                print(say)
            print('')

    def on_key_release(self,symbol,modifiers):

        if symbol in self.longpress:
            del self.longpress[symbol]


    def on_close(self):

        print('\n\nNumber of lines :',compt(self.path))
        gs.save_files(self.path)



    ### LOOP

    def events(self):

        if self.keys[key.Q]:
            self.perso.move('R')
        if self.keys[key.D]:
            self.perso.move('L')

        if self.keys[key.E]:
            if time.time() - self.longpress[key.E] > self.cooldown:
                self.longpress[key.E] = time.time()
                self.perso.rplum()

    def draw(self):

        g.tman.draw()

    def gameloop(self,dt):

        if self.playing:

            # EVENTS
            self.events()

            gl.glClearColor(1/4,1/4,1/4,1)
            # CLR
            self.window.clear()

            # RFRSH

            # DRW
            self.draw()

        else:
            print('\n\nNumber of lines :',compt(self.path))
            gs.save_files(self.path)

            self.window.close()


def main():

    app = App()
    app.init()

if __name__ == '__main__':
    main()



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/colors.py



### colors
c = {

"air" : (0,0,0,0),
"aliceblue" : (240, 248, 255,255),
"antiquewhite" : (250, 235, 215,255),
"aqua" : (0, 255, 255,255),
"aquamarine" : (127, 255, 212,255),
"azure" : (240, 255, 255,255),
"beige" : (245, 245, 220,255),
"bisque" : (255, 228, 196,255),
"black" : (0, 0, 0,255),
"blanchedalmond" : (255, 235, 205,255),
"blue" : (0, 0, 255,255),
"blueviolet" : (138, 43, 226,255),
"brown" : (165, 42, 42,255),
"burlywood" : (222, 184, 135,255),
"cadetblue" : (95, 158, 160,255),
"chartreuse" : (127, 255, 0,255),
"chocolate" : (210, 105, 30,255),
"coral" : (255, 127, 80,255),
"cornflowerblue" : (100, 149, 237,255),
"cornsilk" : (255, 248, 220,255),
"crimson" : (220, 20, 60,255),
"cyan" : (0, 255, 255,255),
"darkblue" : (0, 0, 139,255),
"darkcyan" : (0, 139, 139,255),
"darkgoldenrod" : (184, 134, 11,255),
"darkgray" : (169, 169, 169,255),
"darkgrey" : (169, 169, 169,255),
"darkgreen" : (0, 100, 0,255),
"darkkhaki" : (189, 183, 107,255),
"darkmagenta" : (139, 0, 139,255),
"darkolivegreen" : (85, 107, 47,255),
"darkorange" : (255, 140, 0,255),
"darkorchid" : (153, 50, 204,255),
"darkred" : (139, 0, 0,255),
"darksalmon" : (233, 150, 122,255),
"darkseagreen" : (143, 188, 143,255),
"darkslateblue" : (72, 61, 139,255),
"darkslategray" : (47, 79, 79,255),
"darkslategrey" : (47, 79, 79,255),
"darkturquoise" : (0, 206, 209,255),
"darkviolet" : (148, 0, 211,255),
"deeppink" : (255, 20, 147,255),
"deepskyblue" : (0, 191, 255,255),
"dimgray" : (105, 105, 105,255),
"dimgrey" : (105, 105, 105,255),
"dodgerblue" : (30, 144, 255,255),
"firebrick" : (178, 34, 34,255),
"floralwhite" : (255, 250, 240,255),
"forestgreen" : (34, 139, 34,255),
"fuchsia" : (255, 0, 255,255),
"gainsboro" : (220, 220, 220,255),
"ghostwhite" : (248, 248, 255,255),
"gold" : (255, 215, 0,255),
"goldenrod" : (218, 165, 32,255),
"gray" : (128, 128, 128,255),
"grey" : (128, 128, 128,255),
"green" : (0, 128, 0,255),
"greenyellow" : (173, 255, 47,255),
"honeydew" : (240, 255, 240,255),
"hotpink" : (255, 105, 180,255),
"indianred" : (205, 92, 92,255),
"indigo" : (75, 0, 130,255),
"ivory" : (255, 255, 240,255),
"khaki" : (240, 230, 140,255),
"lavender" : (230, 230, 250,255),
"lavenderblush" : (255, 240, 245,255),
"lawngreen" : (124, 252, 0,255),
"lemonchiffon" : (255, 250, 205,255),
"lightblue" : (173, 216, 230,255),
"lightcoral" : (240, 128, 128,255),
"lightcyan" : (224, 255, 255,255),
"lightgoldenrodyellow" : (250, 250, 210,255),
"lightgray" : (211, 211, 211,255),
"lightgrey" : (211, 211, 211,255),
"lightgreen" : (144, 238, 144,255),
"lightpink" : (255, 182, 193,255),
"lightsalmon" : (255, 160, 122,255),
"lightseagreen" : (32, 178, 170,255),
"lightskyblue" : (135, 206, 250,255),
"lightslategray" : (119, 136, 153,255),
"lightslategrey" : (119, 136, 153,255),
"lightsteelblue" : (176, 196, 222,255),
"lightyellow" : (255, 255, 224,255),
"lime" : (0, 255, 0,255),
"limegreen" : (50, 205, 50,255),
"linen" : (250, 240, 230,255),
"magenta" : (255, 0, 255,255),
"maroon" : (128, 0, 0,255),
"mediumaquamarine" : (102, 205, 170,255),
"mediumblue" : (0, 0, 205,255),
"mediumorchid" : (186, 85, 211,255),
"mediumpurple" : (147, 112, 219,255),
"mediumseagreen" : (60, 179, 113,255),
"mediumslateblue" : (123, 104, 238,255),
"mediumspringgreen" : (0, 250, 154,255),
"mediumturquoise" : (72, 209, 204,255),
"mediumvioletred" : (199, 21, 133,255),
"midnightblue" : (25, 25, 112,255),
"mintcream" : (245, 255, 250,255),
"mistyrose" : (255, 228, 225,255),
"moccasin" : (255, 228, 181,255),
"navajowhite" : (255, 222, 173,255),
"navy" : (0, 0, 128,255),
"oldlace" : (253, 245, 230,255),
"olive" : (128, 128, 0,255),
"olivedrab" : (107, 142, 35,255),
"orange" : (255, 165, 0,255),
"orangered" : (255, 69, 0,255),
"orchid" : (218, 112, 214,255),
"palegoldenrod" : (238, 232, 170,255),
"palegreen" : (152, 251, 152,255),
"paleturquoise" : (175, 238, 238,255),
"palevioletred" : (219, 112, 147,255),
"papayawhip" : (255, 239, 213,255),
"peachpuff" : (255, 218, 185,255),
"peru" : (205, 133, 63,255),
"pink" : (255, 192, 203,255),
"plum" : (221, 160, 221,255),
"powderblue" : (176, 224, 230,255),
"purple" : (128, 0, 128,255),
"red" : (255, 0, 0,255),
"rosybrown" : (188, 143, 143,255),
"royalblue" : (65, 105, 225,255),
"saddlebrown" : (139, 69, 19,255),
"salmon" : (250, 128, 114,255),
"sandybrown" : (244, 164, 96,255),
"seagreen" : (46, 139, 87,255),
"seashell" : (255, 245, 238,255),
"sienna" : (160, 82, 45,255),
"silver" : (192, 192, 192,255),
"skyblue" : (135, 206, 235,255),
"slateblue" : (106, 90, 205,255),
"slategray" : (112, 128, 144,255),
"slategrey" : (112, 128, 144,255),
"snow" : (255, 250, 250,255),
"springgreen" : (0, 255, 127,255),
"steelblue" : (70, 130, 180,255),
"tan" : (210, 180, 140,255),
"teal" : (0, 128, 128,255),
"thistle" : (216, 191, 216,255),
"tomato" : (255, 99, 71,255),
"turquoise" : (64, 224, 208,255),
"violet" : (238, 130, 238,255),
"wheat" : (245, 222, 179,255),
"white" : (255, 255, 255,255),
"whitesmoke" : (245, 245, 245,255),
"yellow" : (255, 255, 0,255),
"yellowgreen" : (154, 205, 50,255),

}



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/getsave.py


"""""
programme sauvegarde de fichiers sources
"""""

# va de pair avec getback v3

version = 3

import os

def save_files(bigpath,path = ['/.','/src'],save_path = '/autosav/'):

    autosav = ''

    for chem in path:
        #print('path',bigpath+chem,':',os.listdir(bigpath+chem))
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    autosav += '\n\n\n _newfile_ :' + bigpath+chem+'/'+file + '\n\n\n'
                    with open(bigpath+chem+'/'+file,'r') as f:
                        autosav += f.read()
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
        version[1]+=1
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])
    except:
        os.makedirs(bigpath+save_path)
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

    with open(bigpath+save_path+'saved_'+version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]+'.savd','w') as f:
        f.write(autosav)

    print('files saved, version',version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

def get_version(bigpath,save_path = '/autosav/'):
    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
    except:
        a=0
    return version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/graphic.py






import pyglet
import src.utils as utils



#manager who rules groups to draw things in the right order u know
class GroupManager():

    def __init__(self):


        self.groups = {} ## give the group with the name

        self.names_wo = {} ## give the name with the order
        self.orders = {} ## give the order with the name

        names = ['back','mid','front','hud','map','up']
        self.distance_btw = 8

        for i in range(len(names)):
            self.groups[names[i]] = pyglet.graphics.OrderedGroup(i*self.distance_btw)
            self.orders[names[i]] = i*self.distance_btw
            self.names_wo[i*self.distance_btw] = names[i]

    def getOrderGroup(self,thg=['back',None],thg2=0):

        name=''

        if thg[0] != None: ## atteint un groupe particulier avec son nom
            name = thg[0]
        elif thg[1] != None: ## atteint un groupe particulier avec son order d'affichage
            return thg[1]

        if thg2 != 0:
            name += str(thg2)

        if name in self.groups:
            return self.orders[name]

        return None

    def getGroup(self,thg=['back',None],thg2=0):

        name = ''

        if thg[0] != None: ## atteint un groupe particulier avec son nom
            name = thg[0]
        elif thg[1] != None: ## atteint un groupe particulier avec son order d'affichage
            name = self.names_wo[thg[1]]

        if thg2 != 0:
            name +=str(thg2)

        if name in self.groups:
            return self.groups[name]

        return None #le groupe n'existe pas

    def createGroup(self,thg=['back',None],thg2=0,level_to_put_in=0):
        group = self.getGroup(thg,thg2)
        if group == None: ## pas encore de groupe créé

            if thg[0] != None:
                if thg2 == 0:
                    return self.quickCreateGroup(thg[0],level_to_put_in)
                else:
                    name = thg[0]+str(thg2)
                    return self.quickCreateGroup(name,self.orders[thg[0]]+thg2)
            elif thg[1] != None:
                try:
                    name = self.names_wo[thg[1]]+str(thg2)
                    return self.quickCreateGroup(name,thg[1]+thg2)
                except :
                    print('chien essaie de regler la creation dun groupe avec order')

        # ah si on est là le groupe était créé
        return group

    def quickCreateGroup(self,name,order):
        if not name in self.groups:
            self.groups[name] = pyglet.graphics.OrderedGroup(order)
            self.orders[name] = order
            self.names_wo[order] = name
            return self.groups[name]
        return self.groups[name] # group was already created

#manager who init images
class TextureManager():

    def __init__(self,path='.'):

        self.textures = {}

        self.path = path

        self.ids = []

        self.batch = pyglet.graphics.Batch()

    def loadImSeq(self,path2,size):

        # size décrit le nb de tiles en w et en h

        path3 = '/item/'
        img = pyglet.image.load(self.path+path3+path2)
        textures = pyglet.image.ImageGrid(img, *size)

        ids = []
        for txt in textures:
            id = utils.get_id('text')
            self.textures[id] = txt

            self.ids.append(id)
            ids.append(id)
        return ids

    def loadIm(self,path2):

        path3 = '/item/'
        id = utils.get_id('img')
        img = pyglet.image.load(self.path+path3+path2)
        self.textures[id] = img
        self.ids.append(id)
        return id

    def draw(self):
        self.batch.draw()

#manager who rules normal sprites
class SpriteManager():

    def __init__(self):

        ## SPRITES

        self.sprites = {}
        self.static_sprites = {}
        self.eff_sprites = {}

        self.ids = []

    def addSpr(self,textid,xy_pos=(0,0),alr_id=-1,vis=True,static=False,eff=False):

        if alr_id == -1:
            id = utils.get_id('spr')
            self.ids.append(id)
        else:
            id =alr_id

        if static:
            self.static_sprites[id] = pyglet.sprite.Sprite(tman.textures[textid], batch=tman.batch)
            self.static_sprites[id].position = xy_pos
            self.static_sprites[id].visible = vis
        elif eff:
            self.eff_sprites[id] = pyglet.sprite.Sprite(tman.textures[textid], batch=tman.batch)
            self.eff_sprites[id].position = xy_pos
            self.eff_sprites[id].visible = vis
        else:
            self.sprites[id] = pyglet.sprite.Sprite(tman.textures[textid], batch=tman.batch)
            self.sprites[id].position = xy_pos
            self.sprites[id].visible = vis

        #self.detect()

        return id

    def addToGroup(self,id,thg=['back',None],thg2=0,level_to_put_in=0,eff=False):

        group = gman.createGroup(thg,thg2,level_to_put_in)

        if not eff:
            try :
                self.sprites[id].group = group
            except:
                self.static_sprites[id].group = group
        else:
            self.eff_sprites[id].group = group

        #self.detect()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                try:
                    if self.sprites[id].visible != (not hide):
                        self.sprites[id].visible = (not hide)
                except:
                    try:
                        if self.static_sprites[id].visible != (not hide):
                            self.static_sprites[id].visible = (not hide)
                    except :
                        if self.eff_sprites[id].visible != (not hide):
                            self.eff_sprites[id].visible = (not hide)

        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)

        else:
            try:
                if self.sprites[tabids].visible != (not hide):
                    self.sprites[tabids].visible = (not hide)
            except:
                try:
                    if self.static_sprites[tabids].visible != (not hide):
                        self.static_sprites[tabids].visible = (not hide)
                except :
                    if self.eff_sprites[tabids].visible != (not hide):
                        self.eff_sprites[tabids].visible = (not hide)

    def set_text(self,sprid,textid):
        if self.sprites[sprid].image != tman.textures[textid]:
            self.sprites[sprid].image = tman.textures[textid]

    def modify(self,sprid,pos=None,scale=None,group=None):

        # position
        x,y = None,None
        if pos != None and pos != (self.sprites[sprid].x,self.sprites[sprid].y):
            x,y = pos

        # scale
        scalex,scaley = None,None
        if scale != None and scale != (self.sprites[sprid].scale_x,self.sprites[sprid].scale_y):
            scalex,scaley = scale

        # updating group
        if group != None:
            group = gman.getGroup(*group)
            if group != self.sprites[sprid].group:
                self.sprites[sprid].group = group

        # final updating positon and scale
        self.sprites[sprid].update(x=x,y=y,scale_x = scalex,scale_y=scaley)

    def spr(self,id):

        if id in self.sprites:
            return self.sprites[id]
        elif id in self.static_sprites:
            return self.static_sprites[id]
        elif id in self.eff_sprites:
            return self.eff_sprites[id]

        return None

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les sprites affichés ingame
            for id in self.sprites:
                self.sprites[id].delete()
            self.sprites = {}
            #print('sprites deleted')

        elif type(tabids) == type('aa'): # on delete un seul sprite precis
            if tabids in self.sprites:
                self.sprites[tabids].delete()
                del self.sprites[tabids]
                #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de sprite
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de sprite
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

    def detect(self):

        errorsS = []
        errorsV = []
        for id in self.sprites:
            if type(self.sprites[id]) != pyglet.sprite.Sprite:
                errorsS.append(id)
            else:
                if self.sprites[id]._vertex_list == None:
                    errorsV.append(id)
        if errorsS != []:
            print('noSprite',errorsS)
        if errorsV != []:
            print('noVertex',errorsV)

#manager who rules normal labels
class LabelManager():

    def __init__(self,font=None):

        if font != None:
            self.font = font
        else:
            self.font = 'arial'

        self.labels = {}
        self.ids = []

    def updateman(self,font=None):

        if font != None:
            self.font = font
        else:
            self.font = 'arial'

    def addLabel(self,contenu,xy_pos=(0,0),alr_id=-1,vis=True,font_name=None,font_size=30,group=None,anchor = ('left','bottom'),color=(255,255,255,255)):

        if alr_id == -1:
            id = utils.get_id('lbl')
            self.ids.append(id)
        else:
            id =alr_id

        if not font_name:
            font_name = self.font


        anchor_x,anchor_y= anchor

        #group = gman.createGroup(['hud'])
        self.labels[id] = pyglet.text.Label(contenu,font_name=font_name,font_size=font_size,group=group, \
                        batch=tman.batch,anchor_x= anchor_x,anchor_y= anchor_y,color=color)
        self.labels[id].x,self.labels[id].y = xy_pos
        self.unhide(id,not vis)
        #self.labels[id].visible = vis

        return id

    def addToGroup(self,id,thg=['back',None],thg2=0,level_to_put_in=0):

        group = gman.createGroup(thg,thg2,level_to_put_in)
        #print('GROUP IS',group)
        self.labels[id]._init_groups(group)
        self.labels[id]._update()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                self.unhide(id,hide)
        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)
        else:
            if hide == False and self.labels[tabids].color[3] == 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],255]
            elif hide == True and self.labels[tabids].color[3] != 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],0]

    def set_text(self,lblid,contenu):
        if self.labels[lblid].text != contenu:
            self.labels[lblid].text = contenu

    def printGroup(self,lblid):
        print('\ttopgroup :',self.labels[lblid].top_group)
        print('\tbackgroup :',self.labels[lblid].background_group)
        print('\tforegroup :',self.labels[lblid].foreground_group)
        print('\tforegroupdeco :',self.labels[lblid].foreground_decoration_group)

    def modify(self,lblid,pos=None,scale=None):

        if scale != None and scale != (self.labels[lblid].scale_x,self.labels[lblid].scale_y):
            self.labels[lblid].update(scale_x = scale[0],scale_y=scale[1])
            #self.labels[lblid].scale_x,self.labels[lblid].scale_y = scale

        if pos != None and pos != (self.labels[lblid].x,self.labels[lblid].y):
            self.labels[lblid].x,self.labels[lblid].y = pos

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les labels affichés ingame
            for id in self.labels:
                self.labels[id].delete()
            self.labels = {}
            #print('labels deleted')

        elif type(tabids) == type('aa'): # on delete un seul label precis
            self.labels[tabids].delete()
            del self.labels[tabids]
            #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de label
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de label
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

#special manager who rules effects sprites
class EffectManager():

    def __init__(self,graphic,textids,size_tile=32):

        self.effects = {}
        #self.groups = {}
        #self.sprites = {}

        self.sprids = {}

        self.size_tile = size_tile

        self.graphic = graphic
        self.textids = textids

    def addEffect(self,name,terrain,dep_pos,order):

        self.effects[name] = terrain
        #self.groups[name] = pyglet.graphics.OrderedGroup(order)

        """created = self.graphic.createGroup(name,order,eff=True)
        if not created:
            self.delete(name)"""

        self.sprids[name] = []

        for j in range(len(terrain)):
            for i in range(len(terrain[j])):
                posx = dep_pos[0] + i*self.size_tile
                posy = dep_pos[1] + j*self.size_tile
                id = self.graphic.addSpr(self.textids[terrain[j][i]],(posx,posy),eff=True)
                self.graphic.addToGroup(id,[name],0,order,True)
                #print('creating',name,id)
                self.sprids[name].append(id)
                #self.sprites[name].append(pyglet.sprite.Sprite(tman.textures[] , batch = tman.batch , group=self.groups[name], x=posx,y=posy  ))
        return name

    def unhide(self,name,hide=False):
        self.graphic.unhide(self.sprids[name],hide)

    def delete(self,name):
        #print(self.sprids[name])
        #print('deleting',name)
        for spr in self.sprids[name]:
            #print('deleting',name,spr)
            self.graphic.eff_sprites[spr].delete()

    def hasEffect(self,name):
        return name in self.effects

#special manager who rules labels I need to see what's wrong (it's my own cmd)
class CmdManager():

    def __init__(self,pos):

        self.batch = pyglet.graphics.Batch()

        self.data = {}
        self.pos = {}
        self.labels = {}
        self.name = ['main','main2']
        for name in self.name:
            self.data[name] = {}
            self.pos[name] = {}
            self.labels[name] = {}


        self.init_pos = pos

        self.font = 'arial'
        self.size_ft = 20

    def draw(self,name='main'):
        self.batch.draw()

    def add(self,lab,data,name='main'):

        already_in = False

        try:
            type(self.data[name][lab])
            already_in = True
        except :
            self.pos[name][lab] = [self.init_pos[0],self.init_pos[1]-25]
            self.init_pos = self.pos[name][lab]

        if type(data) == type(0.001):
            self.data[name][lab] = utils.truncate(data,3)
        else:
            self.data[name][lab] = data

        if not already_in:
            self.labels[name][lab] = pyglet.text.Label(lab+' '+str(self.data[name][lab]),
                            font_name=self.font,
                            font_size=self.size_ft,
                            x=self.pos[name][lab][0],
                            y=self.pos[name][lab][1],
                            batch=self.batch)
        else:
            self.labels[name][lab].text = lab+' '+str(self.data[name][lab])

#special manager for single uses : buttons in menu
class SpecialManager():

    def __init__(self,manager,scrsize):

        self.manager = manager
        self.screen = scrsize

        self.to_draw = {}
        #self.order = []

    def addSpr(self,textid,x,y,name=utils.get_id('spc')):

        thg = pyglet.sprite.Sprite(self.manager.textures[textid])
        thg.position = x,y

        self.to_draw[name] = thg

        return name

    def addLabel(self,text,font_name,font_size,x,y,name=utils.get_id('spc'),color=(0,0,0,255)):
        thg = pyglet.text.Label(text,
                        font_name=font_name,
                        font_size=font_size,
                        anchor_x= 'center',
                        color=color,
                        x=x,y=y)

        self.to_draw[name] = thg

        return name

    def addThg(self,thg,name=utils.get_id('spc')):

        self.to_draw[name] = thg
        return name

    def draw(self,tab):

        for name in tab:
            self.to_draw[name].draw()

## OTHER GRAPHICS CLASS

class Cursor():

    def __init__(self,name,graph,text,skin,thg,thg2=0,pos=(0,0),vis=True):

        self.name = name

        self.textids = text
        self.skin = skin
        self.manager = graph
        id = self.manager.addSpr(self.textids[self.skin],pos,vis=vis)
        self.manager.addToGroup(id,thg,thg2)
        self.order = self.manager.groups.getOrderGroup(thg,thg2)
        self.has_ani = False
        self.id = id

        #return id

    def set_pos(self,pos):
        self.manager.sprites[self.id].position = pos

    def get_pos(self):
        return self.manager.sprites[self.id].position

    def set_ani(self,ani,time=2,skin=0):
        self.has_ani = True
        self.ani = ani
        self.time=time
        self.temp = 0
        self.skin = skin
        self.maj_ani()

    def set_text(self,skin):
        self.has_ani = False
        self.skin = skin
        self.maj_ani()

    def up_skin(self,key=[1]):
        if self.has_ani:
            if key[0] != None:
                self.temp+=key[0]
                if self.temp >= self.time:
                    a = self.temp//self.time
                    self.temp-=(self.time*a)
                    self.skin+=a
                if self.skin >= len(self.ani):
                    self.skin -= len(self.ani)
                elif self.skin < 0:
                    self.skin += len(self.ani)
            elif key[1] != None:
                self.skin=key[1]
                if self.skin >= len(self.ani):
                    self.skin = len(self.ani) - 1
                elif self.skin < 0:
                    self.skin = 0


            self.maj_ani()

    def maj_ani(self):
        if self.manager.sprites[self.id].visible:
            if self.has_ani:
                self.manager.set_text(self.id,self.textids[self.ani[self.skin]])
            else:
                self.manager.set_text(self.id,self.textids[self.skin])

    def delete(self):
        self.manager.delete(self.id)

    def unhide(self,hide=False):
        self.manager.unhide(self.id,hide)

    def is_visible(self):
        return self.manager.sprites[self.id].visible

### managers
tman,gman = TextureManager(),GroupManager()
sman,lman = SpriteManager(),LabelManager()



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/obj.py



import random as r
import json
from src import colors
from src.utils import *
from src import graphic as g

"""""""""""""""""""""""""""""""""""
 INIT
"""""""""""""""""""""""""""""""""""

QUALITIES = ['F'
            ,'D-','D','D+'
            ,'C-','C','C+'
            ,'B-','B','B+'
            ,'A-','A','A+'
            ,'S-','S','S+'
            ,'S*']
QUALITIES_coeff = [0.1
            ,0.2,0.3,0.4
            ,0.5,0.6,0.7
            ,0.75,0.8,0.85
            ,0.9,0.92,0.94
            ,0.96,0.98,0.995
            ,1.1]
QUALITIES_up = {'F':0.1
            ,'D-':0.1,'D':0.1,'D+':0.1
            ,'C-':0.1,'C':0.1,'C+':0.1
            ,'B-':0.05,'B':0.05,'B+':0.05
            ,'A-':0.05,'A':0.02,'A+':0.02
            ,'S-':0.02,'S':0.02,'S+':0.015
            ,'S*':1}
QUALITIES_dwn = {'F':-1,'D-':-0.1
            ,'D':-0.1,'D+':-0.1,'C-':-0.1
            ,'C':-0.1,'C+':-0.1,'B-':-0.1
            ,'B':-0.05,'B+':-0.05,'A-':-0.05
            ,'A':-0.05,'A+':-0.02,'S-':-0.02
            ,'S':-0.02,'S+':-0.02,'S*':-0.015}

CRED = ['pire merde de la terre','sous-merde','merde'
        ,'victime','neutre','thug'
        ,'gangster','gros ganster','ennemi number one']
CRED_coeff = [-95,-80,-50,-10,10,50,80,95,101]

with open('src/mots.json','r') as f:
    MOTS = json.load(f)

THEMES = ['amour','argent','liberté','révolte','egotrip','ovni','famille','mort + dévastation','notoriété','chill','rap']

"""""""""""""""""""""""""""""""""""
 CLASSES BASIK
"""""""""""""""""""""""""""""""""""


#------# phases

class Rappeur():

    def __init__(self,textid,plumtext_id,pos=(200,200),name='Delta'):

        # general

        self.name = name
        self.speed = 50

        self.street_score = 0

        self.money = 1000

        self.nb_fans = 0
        self.fans = []

        self.plume = rplum()
        self.plumtext_id = plumtext_id

        # skins

        self.skin_id = g.sman.addSpr(textid)
        g.sman.modify(self.skin_id,pos,(10,10))
        g.sman.addToGroup(self.skin_id,['up'])

        self.plum_id = g.sman.addSpr(plumtext_id[convert_quality(self.plume.quality)[0]],(1500,40))
        g.sman.modify(self.plum_id,scale=(0.4,0.4))
        g.sman.addToGroup(self.skin_id,['up'])

        # labels

        self.label_name_id = g.lman.addLabel(self.name,(40,40))
        self.label_qua_id = g.lman.addLabel(convert_quality(self.plume.quality)+' ('+trunc(self.plume.quality)+')',(1600,60))
        self.label_cred_id = g.lman.addLabel(convert_streetcred(self.plume.cred_power)+' ('+str(self.plume.cred_power)+')',(1500,10),font_size=20)

    def rplum(self):
        self.plume = rplum()
        self.actualise_skins()


    def actualise_skins(self):

        #self.plum_id = graph.addSpr(plumtext_id[convert_quality(self.plume.quality)[0]],(1500,40))
        g.sman.set_text(self.plum_id,self.plumtext_id[convert_quality(self.plume.quality)[0]])
        g.lman.set_text(self.label_qua_id,convert_quality(self.plume.quality)+' '+trunc(self.plume.quality))
        g.lman.set_text(self.label_cred_id,convert_streetcred(self.plume.cred_power)+' '+str(self.plume.cred_power))


    def move(self,dir):
        x,y = g.sman.spr(self.skin_id).position
        if dir == 'R':
            g.sman.modify(self.skin_id,(x-self.speed,y))
        elif dir == 'L':
            g.sman.modify(self.skin_id,(x+self.speed,y))

class Plume():

    def __init__(self,qua,cred):

        self.quality = qua
        self.cred_power = cred

        self.level = 0

    def drop_phase(self):

        x = 2
        qua = (self.quality*x + r.random())/(x+1)

        x = 3
        cred = (self.cred_power*x + r.randint(-100,100))/(x+1)

        phase = Phase(qua,cred)
        #print(phase.content)
        #print(convert_quality(qua),convert_streetcred(cred))

        return phase

class Phase():

        def __init__(self,quality,cred,):

            self.quality = quality
            self.cred = cred

            self.content = self.generate_content()

            self.them = r.choice(THEMES)

        def generate_content(self):

            nb = r.randint(3,6)
            s = r.choice(MOTS)
            for i in range(nb-1):
                s += ' ' + r.choice(MOTS)
            return s

#------# instrus

class Btmaker():

    def __init__(self,qua=0.5,name='Bokusan'):

        self.name = name

        #self.money = 1000

        self.quality = qua

    def drop_instru(self):

        x = 2
        qua = (self.quality*x + r.random())/(x+1)

        instru = Instru(qua,self.name)
        #print('instru '+convert_quality(qua))
        return instru

class Instru():

    def __init__(self,qua,author):

        self.quality = qua
        self.author = author

#------# sons

class Son():

    def __init__(self,instru,phases,name='cheh'):

        self.name = name

        self.instru = instru
        self.phases = phases

        self.quality = self.global_qua()
        self.cred = max([ x.cred for x in self.phases])

        print(convert_quality(self.quality),convert_streetcred(self.cred))

    def global_qua(self):

        x_instru = 1
        x_phases = 1

        qua_instru = self.instru.quality

        qua_phases = 0
        themes = []
        for ph in self.phases:
            qua_phases += ph.quality
            if ph.them not in themes:
                themes.append(ph.them)
        qua_phases/=len(self.phases)

        qua = (x_instru*qua_instru + x_phases*qua_phases)/(x_instru+x_phases)

        if len(themes) <= 1:
            qua = upgrade_qua(qua,1)
        elif len(themes) > 2:
            qua = upgrade_qua(qua,-1)

        return qua


"""""""""""""""""""""""""""""""""""
 CLASSES GRAFIK
"""""""""""""""""""""""""""""""""""

"""class Zone():

    def __init__(self,box,textid='red',group=['mid']):

        if textid[:4] != 'text':

        else:
            text =
            self.skin_id ="""



"""""""""""""""""""""""""""""""""""
 USEFUL FUNCTIONS
"""""""""""""""""""""""""""""""""""

def test():

    quality = r.random()
    cred_power = r.randint(-100,100)

    print(convert_quality(quality),convert_streetcred(cred_power))

    plum = Plume(quality,cred_power)
    print('\n')
    for i in range(20):
        phaz = []
        for i in range(4):
            phaz.append(plum.drop_phase())
        btmker = Btmaker(r.random())
        Son(btmker.drop_instru(),phaz)

    #return Plume(quality,cred_power)

def rplum():

    quality = r.random()
    cred_power = r.randint(-100,100)

    #print(convert_quality(quality),convert_streetcred(cred_power))

    return Plume(quality,cred_power)

def convert_quality(qua,test=(QUALITIES,QUALITIES_coeff)):


    if qua < test[1][0]:
        return test[0][0]
    else:
        return convert_quality(qua,(test[0][1:],test[1][1:]))

def convert_streetcred(cred,test=(CRED,CRED_coeff)):

    if cred < test[1][0]:
        return test[0][0]
    else:
        return convert_streetcred(cred,(test[0][1:],test[1][1:]))

def upgrade_qua(qua,bonus=True):

    if bonus:
        return qua + QUALITIES_up[convert_quality(qua)]
    else:
        return qua + QUALITIES_dwn[convert_quality(qua)]



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/utils.py






import random,os,ctypes,time
from ctypes import windll, Structure, c_long, byref
from math import *
#from win32gui import GetWindowRect, GetForegroundWindow, GetWindowText


class POINT(Structure):
    _fields_ = [("x", c_long), ("y", c_long)]

class box():

    def __init__(self,x=0,y=0,w=30,h=30):

        self.w = w
        self.h = h
        self.x = x
        self.y = y

    def _wh(self):
        return self.w,self.h

    def _xy(self):
        return self.x,self.y

    def _xywh(self):
        return self.x,self.y,self.w,self.h

    wh = property(_wh)
    xy = property(_xy)
    xywh = property(_xywh)

## partie SCREEN

def get_screen_size():
    user32 = ctypes.windll.user32
    return user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)


## partie random

def choice(thg):

    if type(thg) == type({}):
        return choice(list(thg.keys()))
        #print(thg.keys())
    else:
        return random.choice(thg)

def randmultint(n,a,b=None): #returns n differents numbers between a and b-1

    if b == None:
        return randmultint(n,0,a-1)
    else:
        t = []
        while len(t) < n:
            new = random.randint(a,b-1)
            while new in t:
                new = random.randint(a,b-1)
            t.append(new)
        return t


def get_key_from_value(d,v,s=[]): # v valeur seule, d dic ou tab

    if type(d) == type({}):
        for key,val in d.items():
            if type(val) != type({}) and type(val) != type([]):
                if v == val:
                    return s+[key]
            else:
                ns = get_key_from_value(val,v,s+[key])
                if ns != None:
                    return ns

    elif type(d) == type([]):
        for key in range(len(d)):
            val = d[key]
            if type(val) != type({}) and type(val) != type([]):
                #print(val)
                if v == val:
                    return s+[key]
            else:
                ns = get_key_from_value(val,v,s+[key])
                if ns != None:
                    return ns

    return None

def getMousePos():
    pt = POINT()
    windll.user32.GetCursorPos(byref(pt))
    return pt.x,pt.y

def module(x,y):
    return sqrt(x**2+y**2)

def int_rd(dec):
    if dec < int(dec)+0.5:
        return int(dec)
    else:
        return ceil(dec)

def sign(n):
    if n==0:
        return 0
    else:
        return n//abs(n)

def rangef(a,b,d=1):

    res = []
    if b > a:
        while b>a:
            res.append(a)
            a+=d
    else:
        while abs(b-a)>0:
            res.append(a)
            a+=d

    return res

ids = 1112

def get_id(key):

    global ids

    id = ''+key
    id+=str(ids)
    ids+=1
    return id

def mycopy(thg):

    if type(thg) == type([]):

        res = []

        for i in thg:
            res.append(mycopy(i))

        return res

    else:

        return thg

def trunc(f, n=3):
    '''Truncates/pads a float f to n decimal places without rounding'''
    s = '{}'.format(f)
    if 'e' in s or 'E' in s:
        return '{0:.{1}f}'.format(f, n)
    i, p, d = s.partition('.')
    return '.'.join([i, (d+'0'*n)[:n]])

### PARTIE AUTO-SAUVEGARDE
def compt(bigpath,path = ['/.','/src']):

    long = 0

    for chem in path:
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    with open(bigpath+chem+'/'+file,'r') as f:
                        long += len(f.readlines())
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    return long


# collision
def collision(a,b):
    if (a[0] > b[2]) or (a[2] < b[0]) or (a[1] > b[3]) or (a[3] < b[1]):
        return False #  oklm c'est bon ca collisionne PAS
    else:
        return True # aoutch ca collisionne
