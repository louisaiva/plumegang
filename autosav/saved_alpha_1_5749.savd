


 _newfile_ :Z:\DESKTOP\CODING\plumegang/./plume.py


"""
CODED by deltasfer
enjoy
"""


import pyglet,time,random
from pyglet.window import key
import pyglet.gl as gl
import colorama
from colors import *
colorama.init()

from src.utils import *
from src.colors import *
import src.names as names
import src.getsave as gs
from src import obj as o
from src import perso as p
from src import obj2 as o2
from src import obj3 as o3
from src import graphic as g
from src import menu as m
from src import cmd


CURRENT_PATH = os.path.dirname(os.path.abspath(__file__)) # fopatouché
if ' ' in CURRENT_PATH:
    print('Le chemin d\'acces contient un espace. Le programme va BUGUER SA MERE.')
    print('Changez le programme de place pour un path sans espace svp.')

ESK_QUIT = 0
## pour éviter d'avoir à passer par le menu
FILL_INV = 1
## pour remplir ou non l'inventaire au debut
VSYNC = 1
## utilise la vsync (fps fixé à 60) ou paa

class App():

    ### INIT FUNCTIONS

    def __init__(self):

        self.path = CURRENT_PATH
        self.init_time = time.time()

        ### windows

        self.window = pyglet.window.Window(screen=g.scr.screen,vsync=VSYNC)

        self.window.set_fullscreen()

        self.window.push_handlers(self)
        #self.window.screen = self.get_current_screen()

        ### loading fonts
        font_path = 'item/fonts/'
        self.fonts = ['RaubFont','Bitter-Bold']
        self.font = ['Bitter','RaubFont']
        for ft in self.fonts:
            try:
                pyglet.resource.add_font(font_path+ft+'.otf')
            except:
                try:
                    pyglet.resource.add_font(font_path+ft+'.ttf')
                except :
                    pass

        ### managers
        g.lman.updateman(self.font)

    def init(self):

        # textures/sprites
        if True:

            ##  TEXTURES

            self.create_organise_textures()

            ## Cursor
            g.Cur.init(self.window,g.TEXTIDS['utils'])

            ## SPRITES

            self.bgx,self.bgy = 0,250
            self.bg1dx = 0
            self.bgdx = 0

            self.sprids = {}
            self.sprids['bg-1'] = g.sman.addSpr(g.TEXTIDS['bg-1'],(self.bgx,self.bgy),'sky',key='sky')
            g.sman.modify(self.sprids['bg-1'],scale=(0.75,0.75))
            self.sprids['bg.1'] = g.sman.addSpr(g.TEXTIDS['bg'],(self.bgx,self.bgy),'bg_buildings_loin',key='landscape_far_')
            g.sman.modify(self.sprids['bg.1'],scale=(0.75,0.75))
            self.sprids['bg.2'] = g.sman.addSpr(g.TEXTIDS['bg'],(self.bgx+g.sman.spr(self.sprids['bg.1']).width,self.bgy),'bg_buildings_loin',key='landscape_far_')
            g.sman.modify(self.sprids['bg.2'],scale=(0.75,0.75))

            rect = box(0,0,g.scr.w,250)
            self.sprids['ground'] = g.sman.addCol('gray',rect,'bg_buildings_proche',key='sol')
            self.sprids['bg1.1'] = g.sman.addSpr(g.TEXTIDS['bg1'],(self.bgx,self.bgy),'bg_buildings_proche',key='landscape_proche_')
            g.sman.modify(self.sprids['bg1.1'],scale=(1.2,1.2))
            self.sprids['bg1.2'] = g.sman.addSpr(g.TEXTIDS['bg1'],(self.bgx+g.sman.spr(self.sprids['bg1.1']).width,self.bgy),'bg_buildings_proche',key='landscape_proche_')
            g.sman.modify(self.sprids['bg1.2'],scale=(1.2,1.2))

            ## sprites effects

            self.sprids['effects'] = {}
            sizes = []
            for scr in g.scr.screens:
                if (scr.width,scr.height) not in sizes:
                    sizes.append((scr.width,scr.height))

            for size in sizes:
                self.sprids['effects'][size] = g.sman.addSpr(g.TEXTIDS['blur'],group='up-1',vis=False,key='blur')
                g.sman.modify(self.sprids['effects'][size],scale=size,opacity=150)

            #print(self.sprids['effects'])

        # streets
        if True:

            o2.create_map()

        # humans
        if True:

            ## PERSOS
            self.perso = p.Perso('rapper',fill=FILL_INV,street='home')
            g.Cam.follow(self.perso)
            p.BOTS.append(self.perso)
            # o3.distro.sign(self.perso)

            #poto
            p.BOTS.append(p.Fan('perso3',o2.NY.CITY['home'].rand_pos(),street='home'))
            self.perso.assign_poto(self.perso)


            self.lab_doing = g.lman.addLab(self.perso.poto.doing,(1880,1050),font_size=20,anchor=('right','top'))

            ## FANS/RAPPEURS/GUYS

            # add hum to p.BOTS for each street
            for str in o2.NY.CITY:
                street = o2.NY.CITY[str]
                if street.name not in ['home']:
                    n_str = street.get_random_nb_bots()
                    for i in range(n_str):
                        pos = street.rand_pos()
                        if random.random() < 1/8 and len(names.rappeurs) > 0:
                            hum = p.Rappeur('rapper',pos,street=street.name)
                        else:
                            text = random.choice(['perso','perso2','perso3'])
                            hum = p.Fan(text,pos,street=street.name)
                        p.BOTS.append(hum)

            for shop in o2.NY.shops:
                shop.create_guys()

            # adding all hum to their street
            for hum in p.BOTS+p.GUYS:
                street = o2.NY.CITY[hum.street]

                # on donne les clés de chez eux à chaque bot
                if isinstance(street,o2.PrivateHouse):
                    street.add_owner(hum)
                elif random.random()>0.01:
                    # si le gars n'a pas de maison on lui en donne une, sauf s'il est sdf mdr
                    o2.NY.rd_house().add_owner(hum)

                # et on les ajoute à leur street actuelle
                street.add_hum(hum)

            if len(p.BOTS+p.GUYS) < 200:
                print(p.BOTS+p.GUYS)
            print('IN THIS GAME :',len(p.BOTS+p.GUYS),'bots ---',len(o2.NY.CITY),'streets')

        # cycle
        tabcolor = [(self.sprids['bg-1'],1),
                    (self.sprids['bg.1'],0.9),
                    (self.sprids['bg.2'],0.9),
                    (self.sprids['bg1.1'],0.7),
                    (self.sprids['bg1.2'],0.7),
                    (self.sprids['ground'],0.7)]
        g.Cyc.launch(self.perso,tabcolor)

        # zones
        if True:

            ## ZONES
            # à la maison
            zones = []
            zones.append(o3.Ordi(1990,260,self.perso,o2.NY.CITY['home']))
            zones.append(o3.Studio(2640,225+50,o2.NY.CITY['home']))
            zones.append(o3.Market(450,210,o2.NY.CITY['home']))
            zones.append(o3.Lit(-600,225,o2.NY.CITY['home']))
            o2.NY.CITY['home'].assign_zones(zones)

            # ez cash
            street = o2.NY.rd_street().name
            zones = []
            zones.append(o3.Cash(2900,225,o2.NY.CITY[street]))
            o2.NY.CITY[street].assign_zones(zones)
            print('let\'s find the',street,'!')

            # distrokid
            zones = []
            zones.append(o3.SimpleReleaser(1670,210,o3.distro,o2.NY.CITY['distrokid']))
            o2.NY.CITY['distrokid'].assign_zones(zones)

            o2.NY.CITY[self.perso.street].load()

        # lot of stuff : hud/end/menu/labels/keys/clicks/final
        if True:

            ## items
            self.this_hud_caught_an_item = None

            ## END

            self.tick = 0
            self.day = 0
            self.duree_day = 60 # en secondes
            self.gameover = False

            # menu
            self.create_menu()

            # labels

            self.lab_fps = g.lman.addLab('',(10,1080),group='up',font_name=1,font_size=32,anchor=('left','top'))
            self.lab_day = g.lman.addLab('',(10,1080-32-32),group='up',font_name=1,font_size=32,anchor=('left','top'))
            self.lab_time = g.lman.addLab('',(10,1080-32-32-32),group='up',font_name=1,font_size=20,anchor=('left','top'))
            self.lab_street = g.lman.addLab('',(10,1080-32),group='up',font_name=1,font_size=32,anchor=('left','top'))

            self.fps_times = {'event':[],'ref':[],'draw':[]}
            self.fps_labs = {}
            self.fps_labs['event'] = g.lman.addLab('',(600,0),group='up',font_size=20,anchor=('left','bottom'))
            self.fps_labs['ref'] = g.lman.addLab('',(800,0),group='up',font_size=20,anchor=('left','bottom'))
            self.fps_labs['draw'] = g.lman.addLab('',(960,0),group='up',font_size=20,anchor=('left','bottom'))

            # keys
            g.keys = key.KeyStateHandler()
            self.window.push_handlers(g.keys)

            self.focus = None
            #g.longpress = {}
            #g.cooldown = 0.5

            #joysticks
            joysticks = pyglet.input.get_joysticks()
            if joysticks:
                g.joystick = joysticks[0]
                g.joystick.open()
                g.joystick.push_handlers(self)


            # clicks
            self.clicks = {'L':False,'R':False,'M':[0,0]}
            self.mouse_speed = 0

            # final
            self.action = "play" # play pause
            self.playing = True

            print(red('LOADIN TIME '+trunc(time.time()-self.init_time)+' sec'))
            pyglet.clock.schedule_interval(self.gameloop,0.0000001)
            pyglet.app.run()

    def create_organise_textures(self):

        ### PERSOS
        if True:

            #

            keys = ['perso','perso2','perso3','guy','rapper']
            for x in keys:
                if x == 'rapper':
                    g.TEXTIDS[x] = g.tman.loadImSeq(x+'.png',(1,60))
                else:
                    g.TEXTIDS[x] = g.tman.loadImSeq(x+'.png',(1,40))
            p.update_textures(keys)

        # items
        if True:
            g.TEXTIDS['_son'] = g.tman.loadImSeq('son.png',(1,6))
            g.TEXTIDS['_phaz'] = g.tman.loadImSeq('phaz.png',(1,6))
            g.TEXTIDS['_instru'] = g.tman.loadImSeq('instru.png',(1,6))
            g.TEXTIDS['_plum'] = g.tman.loadImSeq('plum.png',(1,6))
            g.TEXTIDS['utils'] = g.tman.loadImSeq('utils.png',(8,8))

            qua = ['F','D','C','B','A','S']
            g.TEXTIDS['plume'] = {}
            for i in range(len(g.TEXTIDS['_plum'])):
                g.TEXTIDS['plume'][qua[i]] = g.TEXTIDS['_plum'][i]
            del g.TEXTIDS['_plum']

            g.TEXTIDS['phase'] = {}
            for i in range(len(g.TEXTIDS['_phaz'])):
                g.TEXTIDS['phase'][qua[i]] = g.TEXTIDS['_phaz'][i]
            del g.TEXTIDS['_phaz']

            g.TEXTIDS['instru'] = {}
            for i in range(len(g.TEXTIDS['_instru'])):
                g.TEXTIDS['instru'][qua[i]] = g.TEXTIDS['_instru'][i]
            del g.TEXTIDS['_instru']

            g.TEXTIDS['son'] = {}
            for i in range(len(g.TEXTIDS['_son'])):
                g.TEXTIDS['son'][qua[i]] = g.TEXTIDS['_son'][i]
            del g.TEXTIDS['_son']

            ## ux
            g.TEXTIDS['ux'] = g.tman.loadImSeq('items.png',(1,40))

            ## nbs
            g.TEXTIDS['nbs'] = g.tman.loadImSeq('nbs.png',(1,100))

            ## items
            g.TEXTIDS['items'] = {}
            g.TEXTIDS['items']['key'] = g.TEXTIDS['ux'][3]
            g.TEXTIDS['items']['bottle'] = g.TEXTIDS['ux'][7]
            g.TEXTIDS['items']['noodle'] = g.TEXTIDS['ux'][6]
            g.TEXTIDS['items']['m16'] = g.TEXTIDS['ux'][8]
            g.TEXTIDS['items']['micro'] = g.TEXTIDS['ux'][9]
            g.TEXTIDS['items']['apple'] = g.TEXTIDS['ux'][10]
            g.TEXTIDS['items']['secretapple'] = g.TEXTIDS['ux'][11]

        # BG
        if True:
            g.TEXTIDS['bg-1'] = g.tman.loadIm('bg/sky.png')
            g.TEXTIDS['bg'] = g.tman.loadIm('bg/bg'+'.png')
            g.TEXTIDS['bg1'] = g.tman.loadIm('bg/bg1'+'.png')

        # HOME
        if True:
            g.TEXTIDS['home'] = {}
            g.TEXTIDS['home']['back'] = g.tman.loadIm('bg/home/home_back'+'.png',10)
            g.TEXTIDS['home']['front'] = g.tman.loadIm('bg/home/home_front'+'.png')
            g.TEXTIDS['home']['frontanim'] = [g.tman.loadIm('bg/home/home_fanim'+str(i)+'.png') for i in range(1,5)]
            g.TEXTIDS['home']['backanim'] = [g.tman.loadIm('bg/home/home_banim'+str(i)+'.png') for i in range(1,5)]

        # DISTRO
        if True:
            g.TEXTIDS['distrokid'] = {}
            g.TEXTIDS['distrokid']['back'] = g.tman.loadIm('bg/distro/distrokid_shop.png')
            g.TEXTIDS['distrokid']['backanim'] = [g.tman.loadIm('bg/distro/distrokid_anim'+str(i)+'.png') for i in range(1,5)]

        # SHOP
        if True:
            g.TEXTIDS['shop'] = {}
            g.TEXTIDS['shop']['back'] = g.tman.loadIm('bg/shop.png')
            #g.TEXTIDS['shop']['backanim'] = [g.tman.loadIm('bg/distro/shop_anim'+str(i)+'.png') for i in range(1,5)]

        # STREET
        if True:
            g.TEXTIDS['street'] = {}
            g.TEXTIDS['street']['road'] = g.tman.loadIm('bg/street_back.png')
            #g.TEXTIDS['street']['buildings'] = g.tman.loadIm('bg/building1.png')

        # INSIDE BUILDING
        if True:
            g.TEXTIDS['inside'] = {}
            g.TEXTIDS['inside']['back'] = g.tman.loadIm('bg/inside_building.png')

        ## BUILDINGS
        if True:
            g.TEXTIDS['build'] = {}
            g.TEXTIDS['backbuild'] = {}

            nb_build = 5

            #builds : separating front (first 1500x of each build) and back (100x left)
            id = g.tman.loadIm('bg/builds.png')
            img = g.tman.textures[id]

            h = o2.H_BUILD
            w_tot = o2.W_BUILD + o2.W_BACK

            #sides
            for i in range(2):
                txt = ['L','R']
                x = i*(o2.W_SIDE+o2.W_BACK)
                #front
                w = o2.W_SIDE
                text = img.get_region(x, 0, w,h)
                g.TEXTIDS['build'][txt[i]] = g.tman.addText(text)

                #back
                w = o2.W_BACK
                text = img.get_region(x+o2.W_SIDE, 0, w,h)
                g.TEXTIDS['backbuild'][txt[i]] = g.tman.addText(text)

            x = 2*(o2.W_BACK+o2.W_SIDE)
            #builds
            for i in range(nb_build):
                #front
                w = o2.W_BUILD
                text = img.get_region(i*w_tot+x, 0, w,h)
                g.TEXTIDS['build'][i] = g.tman.addText(text)

                #back
                w = o2.W_BACK
                text = img.get_region(i*w_tot+x + o2.W_BUILD, 0, w,h)
                g.TEXTIDS['backbuild'][i] = g.tman.addText(text)

            #o2.builds_key.append(i)

        ## ZONES
        if True:
            g.TEXTIDS['zone'] = {}

            zones = [('distrib',(320,400)),
                    ('lamp',(200,700))
                    ]

            id = g.tman.loadIm('zones.png')
            img = g.tman.textures[id]

            x=0
            for name,wh in zones:
                w,h = wh
                text = img.get_region(x,0,w,h)
                id = g.tman.addText(text)
                g.TEXTIDS['zone'][name] = id
                #cmd.say(name,'texture created id',id)
                x+=w

        ## TRAINS
        if True:

            ids = g.tman.loadImSeq('bg/train.png',(5,1))
            ids.reverse()
            g.TEXTIDS['sbahn'] = ids

        ## sun moon stars ...
        if True:
            g.TEXTIDS['moon'] = g.tman.loadIm('bg/moon.png')
            g.TEXTIDS['sun'] = g.tman.loadIm('bg/sun.png')
            g.TEXTIDS['stars'] = g.tman.loadIm('bg/stars.png')

        ##
        if True:

            g.TEXTIDS['steam'] = g.tman.addCol('lightgray')
            g.TEXTIDS['steam2'] = g.tman.addCol('gray')

            ## huds
            g.TEXTIDS['studhud'] = g.tman.loadIm('studhud.png')
            g.TEXTIDS['ordhud'] = g.tman.loadIm('ordhud.png')

            ## effects
            g.TEXTIDS['blur'] = g.tman.addCol('black',1,1)
            g.TEXTIDS['lights'] = {}

            lux=['doucheXL','doucheL','douche','bigdouche']

            g.TEXTIDS['lights'] = {}
            ids = g.tman.loadImSeq('lum.png',(1,20))
            for i in range(len(lux)):
                g.TEXTIDS['lights'][lux[i]] = ids[i]

    def get_current_screen(self):

        x,y = self.window.get_location()
        for i in range(len(self.screens)):
            scr = self.screens[i]
            if (x >= scr.x and x <= scr.x + scr.width) and (y >= scr.y and y <= scr.y + scr.height):
                return scr
        return self.screens[0]

    def create_menu(self):

        self.menu = m.Menu()
        self.menu_fonct = {'play':self.change_action
                        ,'quit':self.get_out
                        ,'go home':self.perso.tp
                        ,'scr0':self.change_screen
                        ,'scr1':self.change_screen
                        ,'reset':self.menu.reset
                        ,'cheat':self.perso.cheat
                        ,'splum':self.perso.cheat_plumson
                        ,'roll_color':g.Cyc.roll_mode}
        self.menu_args = {'play':['play'],'go home':[0,None,o2.NY.CITY['home']],'scr0':[0],'scr1':[1]}

    def apply_menu(self,res):

        if res:
            if type(res) == type((0,1)):
                for thg in res:
                    self.apply_menu(thg)
            else:
                if res in self.menu_fonct and res in self.menu_args:
                    self.menu_fonct[res](*self.menu_args[res])
                elif res in self.menu_fonct:
                    self.menu_fonct[res]()

    ### ONCE FUNCTIONS

    def game_over(self):

        self.label_gameover = g.lman.addLab('GAME OVER',(1920/2,1080/2),anchor=('center','center'),font_name=1,font_size=200,color=c['darkkhaki'],group='up')
        self.label_gameover2 = g.lman.addLab('GAME OVER',(1920/2,1080/2),anchor=('center','center'),font_name=1,font_size=210,color=c['black'],group='up')

        g.bertran.set_speed(0,0)

    def get_out(self):
        self.playing = False

    def change_action(self,act='play'):

        size_scr = (self.window.screen.width,self.window.screen.height)
        if act == "pause":
            g.sman.unhide(self.sprids['effects'][size_scr])
            self.menu.unhide()
            g.bertran.set_speed(0,0)
        else:
            g.sman.unhide(self.sprids['effects'][size_scr],True)
            self.menu.unhide(True)
            g.bertran.set_speed(0,1)

        self.action = act
        #print('go',act)

        #self.perso.pause(act)

    def change_screen(self,screen_nb):

        screens = g.scr.screens
        screen = screens[screen_nb]

        # on recrée
        newwin = pyglet.window.Window(screen=screen)
        newwin.set_fullscreen()
        newwin.push_handlers(self)
        newwin.push_handlers(g.keys)

        # on supprime l'ancienne window
        self.window.close()
        self.window = newwin

        #on update g.scr
        g.scr.update_screen(self.window)

    def screen_capture(self):

        capture_screen((g.scr.x, g.scr.y, g.scr.w, g.scr.h))
        g.pman.alert('screen capture copied to clipboard !')

    ### PYGLET FUNCTIONS

    def on_key_press(self,symbol,modifiers):

        if not self.focus:

            #print(symbol,key.SLASH,key.BACKSLASH)
            #print(key.__dict__)

            ## real keys
            if symbol == key.F1:
                self.screen_capture()

            elif symbol == key.G:
                g.print_groups()

            elif symbol == key.T:
                cmd.roll_activate(self)
            elif symbol == key.COLON:
                cmd.roll_activate(self,True)

            elif symbol == key.Y:
                cmd.rollhide()

            if self.action == "play":

                if symbol == key.ESCAPE:
                    self.change_action('pause')
                    if not ESK_QUIT:
                        return pyglet.event.EVENT_HANDLED

                elif symbol == key.B:
                    print(self.perso.invhud)
                    print(self.perso.plume)

                if self.perso.alive:

                    if symbol == key.A:
                        self.perso.drop_sel()

                    elif symbol == key.SPACE:
                        if self.perso.MODE == 'peace':
                            self.perso.act()
                        elif self.perso.MODE == 'fight':
                            self.perso.act()

                    elif symbol == key.X:
                        self.perso.hud.rollhide()
                        self.perso.lifehud.rollhide()
                        self.perso.selhud.rollhide()
                        self.perso.fedhydhud.rollhide()

                    elif symbol == key.E:
                        self.perso.invhud.rollhide()

                    elif symbol == key.F:
                        self.perso.roll_mode(['fight','peace'])

                    elif symbol == key.V:

                        # on assigne le bot le plus proche à être le poto
                        if self.perso.nearest_bot():
                            self.perso.assign_poto(self.perso.nearest_bot())
                        else:
                            self.perso.assign_poto(self.perso)

                    elif symbol == key.M:
                        self.perso.bigmap.rollhide()

                    elif symbol == key.TAB:
                        self.perso.relhud.unhide()

                    elif symbol == key.K:
                        self.perso.minirelhud.rollhide()
                        #self.perso.poto.attack_hum(0,self.perso)

                    elif symbol == key.L:
                        self.perso.chartshud.rollhide()

                    elif symbol in [key._1,key._2,key._3,key._4]:
                        self.perso.selected = symbol - key._1
                        #cmd.colorsay('orange','<@>',symbol)

            elif self.action == 'pause':

                if symbol == key.ESCAPE:
                    res = self.menu.unclick()
                    self.apply_menu(res)
                    if not ESK_QUIT:
                        return pyglet.event.EVENT_HANDLED

                elif symbol == key.BACKSPACE:
                    res = self.menu.unclick()
                    self.apply_menu(res)
                    return pyglet.event.EVENT_HANDLED

                elif symbol == key.ENTER:
                    res = self.menu.click()
                    self.apply_menu(res)

                elif symbol == key.UP:
                    self.menu.up()

                elif symbol == key.DOWN:
                    self.menu.down()

        else:
            if symbol == key.ESCAPE:
                cmd.roll_activate(self)
                return pyglet.event.EVENT_HANDLED

    def on_key_release(self,symbol,modifiers):

        if symbol in g.longpress:
            del g.longpress[symbol]

        if self.action == "play" and self.perso.alive:

            if symbol == key.TAB:
                self.perso.relhud.unhide(True)

            elif symbol == key.SPACE:
                self.perso.unact()

    def on_close(self):

        print('\n\nNumber of lines :',compt(self.path))
        gs.save_files(self.path)

    def on_mouse_motion(self,x,y,dx,dy):
        g.M = [x,y]

        if self.action == "play":

            ## CHECK ROLL
            if self.perso.roll != None:
                self.perso.roll.update()
            else:
                ## CHECK ALL UI
                #print(self.this_hud_caught_an_item)

                # lifeUI
                if self.perso.lifehud.ui.visible and self.this_hud_caught_an_item == None:
                    self.perso.lifehud.ui.check_mouse(x,y)

                #all zones
                for zone in o2.NY.CITY[self.perso.street].zones:

                    if zone == 'studio' and self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['studio'].hud and o2.NY.CITY[self.perso.street].zones['studio'].hud.item_caught == None:
                        self.this_hud_caught_an_item = None

                    if zone == 'ordi' and self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['ordi'].hud and o2.NY.CITY[self.perso.street].zones['ordi'].hud.item_caught == None:
                        self.this_hud_caught_an_item = None

                    if o2.NY.CITY[self.perso.street].zones[zone].activated:

                        if zone == 'lit':
                            if o2.NY.CITY[self.perso.street].zones['lit'].hud.ui != None :
                                if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['lit'].hud) : #check si il a caught

                                    o2.NY.CITY[self.perso.street].zones['lit'].hud.ui.check_mouse(x,y)
                                    if o2.NY.CITY[self.perso.street].zones['lit'].hud.ui.caught:
                                            o2.NY.CITY[self.perso.street].zones['lit'].hud.ui.move(x,y)

                        if zone == 'studio':
                            if self.this_hud_caught_an_item == None:
                                for lab in o2.NY.CITY[self.perso.street].zones['studio'].hud.uis:
                                    ui = o2.NY.CITY[self.perso.street].zones['studio'].hud.uis[lab]
                                    if ui != None :
                                        ui.check_mouse(x,y)

                            elif self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['studio'].hud: #check si il a caught
                                if o2.NY.CITY[self.perso.street].zones['studio'].hud.item_caught != None:
                                    ui = o2.NY.CITY[self.perso.street].zones['studio'].hud.item_caught
                                    ui.check_mouse(x,y)
                                    if ui.caught:
                                            ui.move(x,y)

                        if zone == 'ordi':
                            if self.this_hud_caught_an_item == None:
                                for lab in o2.NY.CITY[self.perso.street].zones['ordi'].hud.uis:
                                    ui = o2.NY.CITY[self.perso.street].zones['ordi'].hud.uis[lab]
                                    if ui != None :
                                        ui.check_mouse(x,y)

                            elif self.this_hud_caught_an_item == o2.NY.CITY[self.perso.street].zones['ordi'].hud: #check si il a caught
                                if o2.NY.CITY[self.perso.street].zones['ordi'].hud.item_caught != None:
                                    ui = o2.NY.CITY[self.perso.street].zones['ordi'].hud.item_caught
                                    ui.check_mouse(x,y)
                                    if ui.caught:
                                            ui.move(x,y)

                if self.this_hud_caught_an_item == self.perso.invhud and self.perso.invhud.item_caught == None:
                    self.this_hud_caught_an_item = None
                elif self.this_hud_caught_an_item == self.perso.selhud and self.perso.selhud.item_caught == None:
                    #print('oh yo')
                    self.this_hud_caught_an_item = None

                #print(self.this_hud_caught_an_item)

                # inventUI
                if self.perso.invhud.visible:
                    if self.this_hud_caught_an_item == None:
                        self.perso.invhud.check_hoover(x,y)
                    elif self.this_hud_caught_an_item == self.perso.invhud:
                        self.perso.invhud.item_caught.move(x,y)
                        self.perso.invhud.item_caught.check_mouse(x,y)

                # selUI
                if self.perso.selhud.visible:
                    if self.this_hud_caught_an_item == None:
                        self.perso.selhud.check_hoover(x,y)
                    elif self.this_hud_caught_an_item == self.perso.selhud:
                        self.perso.selhud.item_caught.move(x,y)
                        self.perso.selhud.item_caught.check_mouse(x,y)

                #print(self.this_hud_caught_an_item)

    def on_mouse_press(self,x, y, button, modifiers):

        if self.action == "play":

            butt = ''
            if button == pyglet.window.mouse.LEFT: butt = 'L'
            elif button == pyglet.window.mouse.RIGHT: butt = 'R'

            letsbacktnothingcaught = False
            activated_smthg = False

            ## CHECK ALL UI

            #all hud
            for zone in o2.NY.CITY[self.perso.street].zones:
                if o2.NY.CITY[self.perso.street].zones[zone].activated:

                    if zone == 'lit':
                        zone = o2.NY.CITY[self.perso.street].zones['lit']
                        if zone.hud.ui != None :
                            if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == zone.hud) : #check si il peut catch

                                caught_dropped = zone.hud.catch_or_drop(x,y,self.perso,butt)

                                if caught_dropped == 1: # means caught

                                    if not g.keys[key.LSHIFT]:
                                        # signifie qu'on prend le hud
                                        self.this_hud_caught_an_item = zone.hud
                                    else:
                                        # attrapage rapide dans l'inventaire
                                        self.perso.grab(zone.hud.ui.item,True)
                                        o2.NY.CITY[self.perso.street].zones['lit'].hud.delete_phase()
                                        letsbacktnothingcaught = True
                                        activated_smthg = True

                                elif caught_dropped == -1: # means dropped
                                    letsbacktnothingcaught = True
                                    activated_smthg = True

                                self.on_mouse_motion(x,y,0,0)

                    elif zone == 'studio':
                        zone = o2.NY.CITY[self.perso.street].zones['studio']
                        if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == zone.hud) : #check si il peut catch
                            caught_dropped = zone.hud.catch_or_drop(x,y,self.perso,butt)

                            if caught_dropped == 1: # means caught

                                if not g.keys[key.LSHIFT]:
                                    # signifie qu'on prend le hud
                                    self.this_hud_caught_an_item = zone.hud
                                else:
                                    # attrapage rapide dans l'inventaire
                                    self.perso.grab(zone.hud.item_caught.item,True)
                                    zone.hud.item_caught.delete()
                                    zone.hud.item_caught = None
                                    letsbacktnothingcaught = True
                                    activated_smthg = True

                            elif caught_dropped == -1: # means dropped
                                letsbacktnothingcaught = True
                                activated_smthg = True

                            self.on_mouse_motion(x,y,0,0)

                    elif zone == 'ordi':
                        zone = o2.NY.CITY[self.perso.street].zones['ordi']
                        if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == zone.hud) : #check si il peut catch

                            if zone.hud.uis['main'] != None and self.perso not in zone.hud.uis['main'].item.owners:
                                g.Cur.start_long_press(zone.hud.uis['main'].box,zone.hud.buy_instru)

                            caught_dropped = zone.hud.catch_or_drop(x,y,butt)

                            if caught_dropped == 1: # means caught

                                if not g.keys[key.LSHIFT]:
                                    # signifie qu'on prend le hud
                                    self.this_hud_caught_an_item = zone.hud
                                else:
                                    # attrapage rapide dans l'inventaire
                                    self.perso.grab(zone.hud.item_caught.item,True)
                                    zone.hud.item_caught.delete()
                                    zone.hud.item_caught = None
                                    letsbacktnothingcaught = True
                                    activated_smthg = True
                            elif caught_dropped == -1: # means dropped
                                letsbacktnothingcaught = True
                                activated_smthg = True
                            elif caught_dropped == 2: # means smthg actived
                                activated_smthg = True

                            self.on_mouse_motion(x,y,0,0)

            # inventUI
            if self.perso.invhud.visible:

                if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == self.perso.invhud) : #check si il peut catch
                    caught_dropped = self.perso.invhud.catch_or_drop(x,y,butt)

                    if caught_dropped == 1: # means caught

                        if not g.keys[key.LSHIFT]:
                            # signifie qu'on prend le hud
                            self.this_hud_caught_an_item = self.perso.invhud
                            self.perso.invhud.item_caught.move(x,y)
                            self.perso.invhud.item_caught.check_mouse(x,y)
                        else:
                            # attrapage rapide dans l'inventaire (fin là en dehors de l'inv)
                            self.perso.invhud.quick_catch_and_drop()
                            letsbacktnothingcaught = True
                            activated_smthg = True

                    elif caught_dropped == -1: # means dropped
                        letsbacktnothingcaught = True

                    elif caught_dropped == 2: # means continuely caughtin
                        self.perso.invhud.item_caught.move(x,y)
                        self.perso.invhud.item_caught.check_mouse(x,y)

                    ## si on active ça, ça fait que quand on dépose dans le selhud sur un item deja, ça fait de la merde
                    #self.on_mouse_motion(x,y,0,0)

                #self.perso.invhud.check_hoover(x,y)
                if self.perso.invhud.check_press_btns(x,y):
                    activated_smthg = True

            # selUI
            if self.perso.selhud.visible:

                if (self.this_hud_caught_an_item == None or self.this_hud_caught_an_item == self.perso.selhud) : #check si il peut catch
                    caught_dropped = self.perso.selhud.catch_or_drop(x,y,butt)

                    if caught_dropped == 1: # means caught

                        if not g.keys[key.LSHIFT]:
                            # signifie qu'on prend le hud
                            self.this_hud_caught_an_item = self.perso.selhud
                            self.perso.selhud.item_caught.move(x,y)
                            self.perso.selhud.item_caught.check_mouse(x,y)

                            #self.on_mouse_motion(x,y,0,0)
                        else:
                            # attrapage rapide dans l'inventaire (fin là en dehors de l'inv)
                            self.perso.selhud.quick_catch_and_drop()
                            letsbacktnothingcaught = True
                            activated_smthg = True

                    elif caught_dropped == -1: # means dropped
                        letsbacktnothingcaught = True

                    elif caught_dropped == 2: # 2 means continuely caughtin
                        self.perso.selhud.item_caught.move(x,y)
                        self.perso.selhud.item_caught.check_mouse(x,y)

            ## ON LANCE LA ROLL de dialogue
            if not self.this_hud_caught_an_item and self.perso.alive and not activated_smthg:
                self.perso.rollspeak(g.M)

            if letsbacktnothingcaught:
                self.on_mouse_motion(x,y,0,0)
                self.this_hud_caught_an_item = None

    def on_mouse_release(self,x,y,button,modifiers):
        g.Cur.reset()
        if self.perso.roll != None and self.action == "play" and self.perso.alive:
            self.perso.unroll()

    def on_mouse_drag(self,x, y, dx, dy, buttons, modifiers):
        self.on_mouse_motion(x,y,dx,dy)

    def on_mouse_scroll(self,x, y, scroll_x, scroll_y):

        if self.action == "play":
            if scroll_y > 0:
                self.perso.roll_sel('down')
            elif scroll_y < 0:
                self.perso.roll_sel()

    ## JOYSTICK

    def on_joybutton_press(self,joystick, button):
        print('button',button)

        if joystick == g.joystick:
            if self.action == "play" and self.perso.alive:
                if button == 0:
                    self.perso.act()

    def on_joybutton_release(self,joystick, button):

        if joystick == g.joystick:
            if self.action == "play" and self.perso.alive:
                if button == 0:
                    self.perso.unact()

    def on_joyaxis_motion(self,joystick, axis, value):

        if joystick == g.joystick:
            if self.action == "play" and self.perso.alive:

                if axis == 'ry':
                    if value > 0:
                        self.perso.roll_sel('down')
                    elif value < 0:
                        self.perso.roll_sel()
            #print('axis',axis,value)
            pass

    def on_joyhat_motion(self,joystick, hat_x, hat_y):

        if joystick == g.joystick:
            if self.action == "play" and self.perso.alive:
                if hat_y > 0:
                    self.perso.roll_sel('down')
                elif hat_y < 0:
                    self.perso.roll_sel()

    ## WRITING

    def set_focus(self,dt,focus):
        if self.focus != focus:
            self.focus = focus

    def on_text(self,text):
        if self.focus:
            #print([text])
            if text == '\r':
                self.focus.enter(self.perso)
            else:
                self.focus.caret.on_text(text)
                self.focus.point_input = None

    def on_text_motion(self, motion):
        #print(motion)
        #print(key.UP)
        if self.focus:
            if motion == key.UP:
                self.focus.up()
            elif motion == key.DOWN:
                self.focus.down()
            else:
                self.focus.caret.on_text_motion(motion)

    def on_text_motion_select(self, motion):
        if self.focus:
            self.focus.caret.on_text_motion_select(motion)

    ### LOOP
    def events(self):

        if self.action == "play" and not self.focus:

            if not self.gameover:

                ## moving perso
                if g.keys[key.Q]:
                    self.perso.move('L',run=g.keys[key.LSHIFT])
                if g.keys[key.D]:
                    self.perso.move('R',run=g.keys[key.LSHIFT])
                if g.keys[key.Z]:
                    self.perso.move('up',run=g.keys[key.LSHIFT])
                if g.keys[key.S]:
                    self.perso.move('down',run=g.keys[key.LSHIFT])

                ## actin
                if g.keys[key.SPACE]:
                    self.perso.act()


                if g.joystick:

                    # do thg with joystik
                    """g.joy_dry = g.joystick.ry - g.joy_ry
                    g.joy_ry = g.joystick.ry
                    print(g.joy_dry)"""


                    ## same with joystick
                    speed = self.perso.speed
                    if g.joystick.z > 0.4:
                        speed = self.perso.runspeed

                    ## moving perso
                    if g.joystick.x < -0.4:
                        self.perso.move('L',speed)
                    elif g.joystick.x > 0.4:
                        self.perso.move('R',speed)
                    if g.joystick.y < -0.4:
                        self.perso.move('up')
                    elif g.joystick.y > 0.4:
                        self.perso.move('down')

                    ## actin
                    #print(g.joystick.buttons)
                    #print(g.joystick.__dict__)
                    if g.joystick.z < -0.4:
                        self.perso.act()

            if g.keys[key.LEFT] or g.keys[key.RIGHT]:
                if g.keys[key.RIGHT]:
                    g.GodCam.activate('R')
                if g.keys[key.LEFT]:
                    g.GodCam.activate()
            else:
                g.GodCam.unactivate(self.perso)

    def draw(self):

        g.tman.draw()

    def refresh(self):

        ## FPS
        dt = time.time() - self.lab_fps_time
        self.lab_fps_time = time.time()
        if dt > 0:
            self.lab_fps1.append(int(1/dt))
        if len(self.lab_fps1) > 0:
            if len(self.lab_fps1) > 10:
                del self.lab_fps1[0]
            moyfps = int(sum(self.lab_fps1)/len(self.lab_fps1))
            g.FPS = moyfps
            g.lman.set_text(self.lab_fps,'FPS : '+str(moyfps))

        ## TIMES
        for key in self.fps_times:
            if len(self.fps_times[key]) > 0:
                if len(self.fps_times[key]) > 30:
                    del self.fps_times[key][0]
                moyfps = sum(self.fps_times[key])/len(self.fps_times[key])
                g.lman.set_text(self.fps_labs[key],key+' : '+trunc(moyfps,3))

        ## PLAYIN
        if self.action == "play":

            # LABELS
            if True:
                # STREETS LABEL
                g.lman.set_text(self.lab_street,self.perso.street)

                # DAYS LABEL
                g.lman.set_text(self.lab_day,'DAY : '+str(g.Cyc.day))

                # HOUR LABEL
                g.lman.set_text(self.lab_time,'  '+str(g.Cyc))

            perso_street = o2.NY.CITY[self.perso.street]
            # STREETS
            perso_street.update(g.Cam.X+ g.GodCam.X,g.Cam.Y)

            # PERSOS
            if True:
                #--# persos
                ## update catalog:
                perso_street.update_catalog()
                for hum in perso_street.humans:
                    # update
                    hum.update(perso_street.name,g.Cam.X + g.GodCam.X,g.Cam.Y)
                    hum.being_bot()
                    hum.check_do()

            # GUYS
            if True:

                # refresh the guys all over the city
                for guy in p.GUYS:
                    if guy.work_hours != None:
                        hm_begin,hm_end = guy.work_hours
                        if g.Cyc >= hm_begin-g.Hour(1) and g.Cyc < hm_end and not guy.workin:
                            guy.work()
                        elif (g.Cyc < hm_begin or g.Cyc >= hm_end) and guy.workin:
                            guy.stop_work()
                    if guy.street != self.perso.street and o2.NY.CITY[guy.street] not in perso_street.neighbor:
                        guy.lil_check_colli()
                        guy.being_bot()
                        guy.check_do()

            # NEIGHBOR STREETS
            if True:

                for street in perso_street.neighbor:
                    street.update_catalog()
                    for hum in street.humans:
                        hum.update(perso_street.name,g.Cam.X + g.GodCam.X,g.Cam.Y)
                        hum.being_bot()
                        hum.check_do()

            # BG
            if True:

                #--# bg
                w = g.sman.spr(self.sprids['bg.1']).width
                x_bg1,y_bg1 = self.bgx+g.Cam.X*0.2 +self.bgdx + g.GodCam.X,g.Cam.Y*0.2 +self.bgy
                x_bg2,y_bg2 = self.bgx+g.Cam.X*0.2 +w +self.bgdx+ g.GodCam.X,g.Cam.Y*0.2 +self.bgy

                if x_bg1 >= 0:
                    self.bgdx -= w
                elif x_bg2 + w <= 1920:
                    self.bgdx += w

                g.sman.modify(self.sprids['bg.1'],(x_bg1,y_bg1))
                g.sman.modify(self.sprids['bg.2'],(x_bg2,y_bg2))

                #bg1
                w = g.sman.spr(self.sprids['bg1.1']).width
                x_bg1,y_bg1 = self.bgx+g.Cam.X*0.4 +self.bg1dx + g.GodCam.X,g.Cam.Y*0.4 +self.bgy
                x_bg2,y_bg2 = self.bgx+g.Cam.X*0.4 +w +self.bg1dx+ g.GodCam.X,g.Cam.Y*0.4 +self.bgy

                if x_bg1 >= 0:
                    self.bg1dx -= w
                elif x_bg2 + w <= 1920:
                    self.bg1dx += w

                g.sman.modify(self.sprids['bg1.1'],(x_bg1,y_bg1))
                g.sman.modify(self.sprids['bg1.2'],(x_bg2,y_bg2))

            # BAHN
            for sbahn in o2.NY.BAHN:
                o2.NY.BAHN[sbahn].update(g.Cam.X+ g.GodCam.X,g.Cam.Y)
                for street in o2.NY.BAHN[sbahn].circuit:
                    o2.NY.CITY[street].station.update()

            # CAM
            if True:
                g.Cam.update(perso_street)

            # if not pause, go streamin and particles
            if g.bertran.speed > 0:

                ## particles
                g.pman.modify('icons',dy=0.1)
                g.pman.modify('dmg',dy=0.1,ux=g.Cam.X+ g.GodCam.X)
                g.pman.modify('bullet',ux=g.Cam.X+ g.GodCam.X)
                #g.pman.modify('bullet',dx=1)

                ## fans are streaming
                for i in range(len(self.perso.disco)):
                    chance = random.randint(0,int(60*g.FPS))
                    malus = 1-i*0.2
                    if chance < self.perso.nb_fans*malus:
                        random.choice(p.BOTS+p.GUYS).stream(self.perso.disco[i])

                ## updates charts
                #p.update_charts()

            text_lab = (self.perso.poto.bigdoing['lab'],list(map(lambda x:x['lab'],self.perso.poto.todo)),self.perso.poto.doing)
            g.lman.set_text(self.lab_doing,text_lab)
            self.perso.hud.update()
            self.perso.bigmap.update()

            if self.perso.money <= 0 or not self.perso.alive:
                self.gameover = True
                self.game_over()

    def gameloop(self,dt):

        if self.playing:
            if self.tick == 0:

                self.lab_fps_time = time.time()
                self.lab_fps1 = []

            self.tick += 1

            # EVENTS
            t = time.time()
            self.events()
            self.fps_times['event'].append(time.time()-t)

            # CLR
            gl.glClearColor(1/4,1/4,1/4,1)
            self.window.clear()

            #gl.glEnable(gl.GL_TEXTURE_2D)
            #gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST)

            # RFRSH
            t = time.time()
            self.refresh()
            self.fps_times['ref'].append(time.time()-t)

            # DRW
            t = time.time()
            self.draw()
            self.fps_times['draw'].append(time.time()-t)

        else:
            print('\n\nNumber of lines :',compt(self.path))
            gs.save_files(self.path)

            self.window.close()

def main():

    app = App()
    app.init()

if __name__ == '__main__':
    main()



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/cmd.py


"""
CODED by deltasfer
enjoy
"""

from src import perso as p
from src import graphic as g
from src import obj2 as o2
from src import obj3 as o3
import pyglet,time
from colors import *
from src.colors import *
from src.utils import *
import random as r
import plume

CMD_TRY = False
# useful for resolving bug in the functions

# DOC:
#  @ -> mean yourself / your street
#  # -> mean nearest bot
#  ¤ -> a thing (it depends) (ex: /tp_street Delta ¤) -> means tp Delta to the street of Delta (useless we agree but still)
#  * -> everyone / everything
#  & -> rue principale / poto
#  ° -> random bot/street
#
#  <wesh la zone> -> pour écrire des trucs contenant des espaces (ex: noms de rues etc)

# useful
def get_hum(name):

    if name == '@':
        if hasattr(Cmd,'perso'):
            return Cmd.perso
    elif name == '#':
        if hasattr(Cmd,'perso'):
            return Cmd.perso.nearest_bot()
    elif name == '&':
        if hasattr(Cmd,'perso'):
            return Cmd.perso.poto
    elif name == '°':
        return r.choice(p.GUYS+p.BOTS)

    for h in p.BOTS+p.GUYS:
        if h.name == name or h.id == name:
            return h

def get_item(name,*args):

    item = None
    if name in o3.catalog_items:

        arg = []

        if o3.catalog_items[name]['param'] and args != []:
            arg = args
        elif o3.catalog_items[name]['param']:
            arg = o3.catalog_items[name]['param']

        if CMD_TRY:
            try:
                item = o3.catalog_items[name]['elem'](*arg)
            except:
                return 'error in the parameters'
        else:
            item = o3.catalog_items[name]['elem'](*arg)

    return item

def get_street(name,hum=None):
    if name == '@':
        if hasattr(Cmd,'perso'):
            return o2.NY.CITY[Cmd.perso.street]

    elif name == '°':
        return o2.NY.rd_street()

    if name == '&':
        return o2.NY.CITY[o2.rue_princ]

    if name == '¤' and hum:
        return o2.NY.CITY[hum.street]

    if name in o2.NY.CITY:
        return o2.NY.CITY[name]

# dic of cmds
def cmds():

    # tps
    def tp(name,x=None,y=None,street='¤'):

        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        if type(x) == type('wesh'):
            if x.isnumeric():
                x = int(x)
            elif x[0] == '+':
                dx = int(x[1:])
                x = hum.gex + dx
            elif x[0] == '-':
                dx = int(x[1:])
                x = hum.gex - dx
            elif x=='None':
                x = None
            else:
                # ça veut dire qu'on a pas réussi à trouver l'humain de destination, estce une street ?
                ret = tp_street(name,x)
                if not ret:
                    return

                # on essaie de créer trouver un humain pour la destination finale
                ret = tp_to_perso(name,x)
                if not ret:
                    return
                else:
                    return 'error : 2nd parameter nor x, nor human, nor street :/'

        if type(y) == type('wesh'):
            if y.isnumeric():
                y = int(y)
            elif y[0] == '+':
                dy = int(y[1:])
                y = hum.gey + dy
            elif y[0] == '-':
                dy = int(y[1:])
                y = hum.gey - dy
            else:
                y = None

        street = get_street(street,hum)
        if not street:
            return 'street not found'

        hum.tp(x,y,street)

    def tp_self(x='None',y='None',street='None'):

        hum = get_hum('@')
        if not hum:
            return 'entity not found'
        return tp(hum.id,x,y,street)

    def tp_street(name,street):
        return tp(name,'None','None',street)

    def tp_to_perso(name,dest_name):

        dest = get_hum(dest_name)
        if not dest:
            return 'destination entity not found'

        gex,gey,street = dest.gex,dest.gey,dest.street
        return tp(name,gex,gey,street)

    # general perso
    def set_streams(name,qté):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        if qté: qté = int(qté)

        hum.nb_streams = qté

    def add_streams(name,qté):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        if qté: qté = int(qté)

        hum.nb_streams += qté

    def set_money(name,qté):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        if qté: qté = int(qté)

        hum.money = qté

    def add_money(name,qté):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        if qté: qté = int(qté)

        hum.add_money(qté)

    def set_fans(name,qté):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        if qté:
            qté = int(qté)

        hum.nb_fans = qté

    # items
    def give(name,item_name,*args):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        #if qté:qté=int(qté)

        #print(args)
        newarg = []
        if args != ():
            for arg in args:
                if type(arg) == type('wesh') and arg.isnumeric():
                    arg = int(arg)
                newarg.append(arg)

        #print(newarg)
        item = get_item(item_name,*newarg)
        if type(item) == type('wesh'):
            return item
        elif not item:
            return 'item not found'

        hum.grab(item)

    # perso godmode, kill toussa toussa
    def wesh():
        hum = get_hum('@')
        if not hum:
            return 'self not found'
        #print('oh yo',hum,hum.name)
        ret = set_fans(hum.name,r.randint(10000,20000))
        if ret:
            return ret

        ret = add_money(hum.name,r.randint(10000000,20000000))
        if ret:
            return ret

        hum.damage = 300
        hum.max_life = 3000
        hum.life = hum.max_life
        hum.confidence = 100

    def esh():
        return wesh()

    def cheh():
        return wesh()

    def kill(name):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        dmg(name,hum.max_life)

    def stop(name):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        colorsay('orange','a command just immobilized',hum.name)
        hum.immobilised = True

    def free(name):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        colorsay('orange','a command just freed',hum.name)
        hum.immobilised = False

    def dmg(name,qté='20'):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        hitter = get_hum('@')
        if not hitter:
            return '@ not found'

        if qté: qté = int(qté)

        hum.be_hit(hitter,qté)

    def heal(name,qté='20'):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        if qté : qté = int(qté)

        hum.add_life(qté)

    def perso(name='@',mode='general'):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        if mode == 'general':
            return '<@> '+ str(hum)
        if mode == 'graphic':
            return '<@> '+hum.str_graphic()
        return mode

    def poto(name='@'):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        perso = get_hum('@')
        if not perso:
            return '@ not found'

        perso.assign_poto(hum)
        return '<@> '+ hum.name + ' assigned to poto'

    def gex(name='@'):
        hum = get_hum(name)
        if not hum:
            return 'entity not found'

        return '<@> '+ str(hum.gex)

    # id
    def get_id():
        hum = None
        if hasattr(Cmd,'perso'):
            hum = Cmd.perso
        if not hum:
            return 'self not found'

        if len(hum.hum_env) > 0:
            bot = hum.hum_env[0]
            #colorsay('green',)
            return '<@> target bot is '+bot.name+', id:'+bot.id
        else:
            return '<@> '+hum.name+' is alone, id:'+hum.id

    def street(street=None):

        if street:
            street = get_street(street)
            if street:
                return '<@> '+street.__repr__()
            else:
                return 'street not found'
        else:
            return '<@> '+o2.NY.name+' city : '+str(len(o2.NY.CITY))+' streets'

    #train
    def sbahn_speed(spd='None'):
        if spd == 'None':
            spd = o2.NY.BAHN['sbahn'].max_speed
            return '<@> sbahn speed is '+str(spd)
        else:
            if spd: spd = int(spd)
            o2.NY.BAHN['sbahn'].max_speed = spd

    # time/tick
    def tick(tick=None):

        if tick:
            tick = int(tick)
            g.Cyc.tick_set(tick)
        else:
            tick = g.Cyc.tick
            return '<@> tick is at '+str(tick)

    def time(h=None,m=None):

        if not h and not m:
            return '<@> time is '+str(g.Cyc)

        return '<@> not coded yet ^^*'

        tick = int(tick)
        g.Cyc.tick_set(tick)

    def cheat():
        return '<@> well tried .. but try harder (cheh)'

    # general
    def quit():
        plume.app.get_out()
        return 'error'

    # sman
    def spr(id=None):

        if not id:
            return str(g.sman)

        return 'wesh'

    return locals()
commands = cmds()

##### CONSOLE

class Console():

    def __init__(self):

        self.window = None

        self.historic = []
        self.ids = []
        self.x,self.y = 10,300
        self.dt = 128
        self.size = 16
        self.max_length = 25
        self.visible = True

        self.font = 'Consolas'
        self.activated = False

        ## PARTIE DOCUMENT
        self.document = pyglet.text.document.UnformattedDocument()
        self.document.set_style(0, len(self.document.text), dict(font_name =self.font, font_size = self.size, color =(255, 255, 255, 255)))

        #self.document.font_name = self.font
        font = self.document.get_font()
        height = font.ascent - font.descent

        self.layout = pyglet.text.layout.IncrementalTextLayout(self.document, 3*g.scr.w//4, height, batch=g.tman.batch,group=g.gman.getGroup('up'))
        self.layout.position = self.x,self.y-3*self.size
        self.caret = pyglet.text.caret.Caret(self.layout,batch=g.tman.batch, color =(255, 255, 255))
        self.caret.set_style({'font_name':self.font,'font_size':self.size,'color':(255,255,255)})

        self.input_historic = []
        self.point_input = None

    def roll_activate(self,window=None,cmd=False):
        if not self.activated:
            self.bg = g.sman.addCol('black_faded',box(w=g.scr.w,h=g.scr.h),group='up-1')

            # Rectangular outline
            pad = 2
            font = self.document.get_font()
            height = font.ascent - font.descent

            self.rect = g.sman.addCol('black_faded',box(x=self.x-2 , y=self.y-3*self.size - 2 , w=3*g.scr.w//4 + 2,h=height + 2),group='up-1')

            self.activated = True
            pyglet.clock.schedule_once(window.set_focus,0.2,self)
            if cmd: self.document.text = '/'
            self.caret.position = len(self.document.text)
        else:
            # on delete le bg
            if hasattr(self,'bg'):
                g.sman.delete([self.bg,self.rect])
                del self.bg
                del self.rect
            self.activated = False
            window.focus = None
            self.document.text = ''
        self.window = window

    def enter(self,hum):
        if self.activated:
            self.perso = hum

            txt = self.document.text
            if len(txt) > 0 and txt[0] == '/':

                command = txt[1:]

                par = command.split(' ')
                while '' in par:
                    par.remove('')

                ## adjustment
                newpar = []
                i = 0
                while i < len(par):

                    x = len(newpar)

                    if par[i][0] == '<':
                        for j in range(i,len(par)):
                            if par[j][-1] == '>':

                                if i != j:

                                    s = []
                                    s.append(par[i][1:])
                                    for y in range(i+1,j):
                                        s.append(par[y])
                                    s.append(par[j][:-1])

                                    newpar.append(' '.join(s))
                                    i=j
                                else:
                                    newpar.append(par[i][1:-1])
                                break

                    if len(newpar) == x:
                        newpar.append(par[i])
                    i+=1
                par = newpar

                ## lezgo cmd
                if par[0] not in commands:
                    self.colorsay('red','command not found')
                    return
                else:

                    if CMD_TRY:# là on try:
                        try:
                            result = commands[par[0]]( *par[1:] )
                            if result == None:
                                self.colorsay('green','command sucessful !')
                                if self.document.text in self.input_historic:
                                    self.input_historic.remove(self.document.text)
                                self.input_historic.append(self.document.text)
                                self.roll_activate(self.window)
                                return
                            else:
                                self.colorsay('orange',result)
                        except:
                            self.colorsay('red','error in the cmd')
                            return

                    else:# là on try pas

                        result = commands[par[0]]( *par[1:] )
                        if result == None:
                            self.colorsay('green','command sucessful !')
                            if self.document.text in self.input_historic:
                                self.input_historic.remove(self.document.text)
                            self.input_historic.append(self.document.text)
                            self.roll_activate(self.window)
                            return
                        else:
                            self.colorsay('orange',result)
            else:
                #self.say('<'+hum.name+'>',self.document.text)
                hum.say(self.document.text)

            if self.document.text in self.input_historic:
                self.input_historic.remove(self.document.text)
            self.input_historic.append(self.document.text)
            self.document.text = ''

    def enter_say(self,thg,hum,color=None):
        if color:
            self.colorsay(color,'<'+hum.name+'>',thg)
        else:
            self.say('<'+hum.name+'>',thg)

    def say(self,*args):

        args = [str(x) for x in args]
        cmd = ' '.join(args)
        print(*args)
        self.historic.append(cmd)
        if self.visible:
            for id in self.ids:
                g.pman.modify_single(id,dy=self.size+2)
            id = g.pman.addLabPart(cmd,self.pos,self.dt,font_name=self.font,font_size=self.size,anchor=('left','center'),key='cmd',vis=self.visible,group='up',use_str_bien=False)
            self.ids.append(id)
            if len(self.ids) >= self.max_length:
                del self.ids[0]

    def colorsay(self,col,*args):

        args = [str(x) for x in args]
        cmd = ' '.join(args)


        self.historic.append(cmd)
        if self.visible:
            for id in self.ids:
                g.pman.modify_single(id,dy=self.size+2)
            id = g.pman.addLabPart(cmd,self.pos,self.dt,font_name=self.font,font_size=self.size,color=c[col],anchor=('left','center'),key='cmd',vis=self.visible,group='up',use_str_bien=False)
            self.ids.append(id)
            if len(self.ids) >= self.max_length:
                del self.ids[0]

        # on le dit aussi dans le print
        if col == 'orange':
            col = 'yellow'
        print(color(cmd,col))

    def rollhide(self):
        g.pman.unhide('cmd',self.visible)
        if hasattr(self,'bg'): g.sman.unhide([self.bg,self.rect],self.visible)
        self.visible = not self.visible

    def up(self):
        if not self.point_input:
            self.point_input = 0
        if len(self.input_historic) >= abs(self.point_input - 1):
            self.point_input -= 1
            self.document.text = self.input_historic[self.point_input]
            self.caret.position = len(self.document.text)

    def down(self):
        if self.point_input:
            self.point_input += 1
            if self.point_input < 0:
                self.document.text = self.input_historic[self.point_input]
                self.caret.position = len(self.document.text)
            else:
                self.point_input = None
                self.document.text = ''
                self.caret.position = len(self.document.text)

    #
    def pos():
        def fget(self):
            return self.x,self.y
        def fset(self, value):
            self.x,self.y = value
        return locals()
    pos = property(**pos())

Cmd = Console()

def colorsay(*args): Cmd.colorsay(*args)
def say(*args): Cmd.say(*args)
def rollhide(*args): Cmd.rollhide(*args)
def enter(*args): Cmd.enter(*args)
def roll_activate(*args): Cmd.roll_activate(*args)
def enter_say(*args): Cmd.enter_say(*args)



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/colors.py



### colors
c = {

    "air" : (0,0,0,0),
    "aliceblue" : (240, 248, 255,255),
    "antiquewhite" : (250, 235, 215,255),
    "aqua" : (0, 255, 255,255),
    "aquamarine" : (127, 255, 212,255),
    "azure" : (240, 255, 255,255),
    "beige" : (245, 245, 220,255),
    "bisque" : (255, 228, 196,255),
    "black" : (0, 0, 0,255),
    "blanchedalmond" : (255, 235, 205,255),
    "blue" : (0, 0, 255,255),
    "blueviolet" : (138, 43, 226,255),
    "brown" : (165, 42, 42,255),
    "burlywood" : (222, 184, 135,255),
    "cadetblue" : (95, 158, 160,255),
    "chartreuse" : (127, 255, 0,255),
    "chocolate" : (210, 105, 30,255),
    "coral" : (255, 127, 80,255),
    "cornflowerblue" : (100, 149, 237,255),
    "cornsilk" : (255, 248, 220,255),
    "crimson" : (220, 20, 60,255),
    "cyan" : (0, 255, 255,255),
    "darkblue" : (0, 0, 139,255),
    "darkcyan" : (0, 139, 139,255),
    "darkgoldenrod" : (184, 134, 11,255),
    "darkgray" : (169, 169, 169,255),
    "darkgrey" : (169, 169, 169,255),
    "darkgreen" : (0, 100, 0,255),
    "darkkhaki" : (189, 183, 107,255),
    "darkmagenta" : (139, 0, 139,255),
    "darkolivegreen" : (85, 107, 47,255),
    "darkorange" : (255, 140, 0,255),
    "darkorchid" : (153, 50, 204,255),
    "darkred" : (139, 0, 0,255),
    "darksalmon" : (233, 150, 122,255),
    "darkseagreen" : (143, 188, 143,255),
    "darkslateblue" : (72, 61, 139,255),
    "darkslategray" : (47, 79, 79,255),
    "darkslategrey" : (47, 79, 79,255),
    "darkturquoise" : (0, 206, 209,255),
    "darkviolet" : (148, 0, 211,255),
    "deeppink" : (255, 20, 147,255),
    "deepskyblue" : (0, 191, 255,255),
    "dimgray" : (105, 105, 105,255),
    "dimgrey" : (105, 105, 105,255),
    "dodgerblue" : (30, 144, 255,255),
    "firebrick" : (178, 34, 34,255),
    "floralwhite" : (255, 250, 240,255),
    "forestgreen" : (34, 139, 34,255),
    "fuchsia" : (255, 0, 255,255),
    "gainsboro" : (220, 220, 220,255),
    "ghostwhite" : (248, 248, 255,255),
    "gold" : (255, 215, 0,255),
    "goldenrod" : (218, 165, 32,255),
    "gray" : (128, 128, 128,255),
    "grey" : (128, 128, 128,255),
    "green" : (0, 128, 0,255),
    "greenyellow" : (173, 255, 47,255),
    "honeydew" : (240, 255, 240,255),
    "hotpink" : (255, 105, 180,255),
    "indianred" : (205, 92, 92,255),
    "indigo" : (75, 0, 130,255),
    "ivory" : (255, 255, 240,255),
    "khaki" : (240, 230, 140,255),
    "lavender" : (230, 230, 250,255),
    "lavenderblush" : (255, 240, 245,255),
    "lawngreen" : (124, 252, 0,255),
    "lemonchiffon" : (255, 250, 205,255),
    "lightblue" : (173, 216, 230,255),
    "lightred" : (235, 98, 85,255),
    "lightcoral" : (240, 128, 128,255),
    "lightcyan" : (224, 255, 255,255),
    "lightgoldenrodyellow" : (250, 250, 210,255),
    "lightgray" : (211, 211, 211,255),
    "lightgrey" : (211, 211, 211,255),
    "lightgreen" : (144, 238, 144,255),
    "lightpink" : (255, 182, 193,255),
    "lightsalmon" : (255, 160, 122,255),
    "lightseagreen" : (32, 178, 170,255),
    "lightskyblue" : (135, 206, 250,255),
    "lightslategray" : (119, 136, 153,255),
    "lightslategrey" : (119, 136, 153,255),
    "lightsteelblue" : (176, 196, 222,255),
    "lightyellow" : (255, 255, 224,255),
    "lime" : (0, 255, 0,255),
    "limegreen" : (50, 205, 50,255),
    "linen" : (250, 240, 230,255),
    "magenta" : (255, 0, 255,255),
    "maroon" : (128, 0, 0,255),
    "mediumaquamarine" : (102, 205, 170,255),
    "mediumblue" : (0, 0, 205,255),
    "mediumorchid" : (186, 85, 211,255),
    "mediumpurple" : (147, 112, 219,255),
    "mediumseagreen" : (60, 179, 113,255),
    "mediumslateblue" : (123, 104, 238,255),
    "mediumspringgreen" : (0, 250, 154,255),
    "mediumturquoise" : (72, 209, 204,255),
    "mediumvioletred" : (199, 21, 133,255),
    "midnightblue" : (25, 25, 112,255),
    "mintcream" : (245, 255, 250,255),
    "mistyrose" : (255, 228, 225,255),
    "moccasin" : (255, 228, 181,255),
    "navajowhite" : (255, 222, 173,255),
    "navy" : (0, 0, 128,255),
    "oldlace" : (253, 245, 230,255),
    "olive" : (128, 128, 0,255),
    "olivedrab" : (107, 142, 35,255),
    "orange" : (255, 165, 0,255),
    "orangered" : (255, 69, 0,255),
    "orchid" : (218, 112, 214,255),
    "palegoldenrod" : (238, 232, 170,255),
    "palegreen" : (152, 251, 152,255),
    "paleturquoise" : (175, 238, 238,255),
    "palevioletred" : (219, 112, 147,255),
    "papayawhip" : (255, 239, 213,255),
    "peachpuff" : (255, 218, 185,255),
    "peru" : (205, 133, 63,255),
    "pink" : (255, 192, 203,255),
    "plum" : (221, 160, 221,255),
    "powderblue" : (176, 224, 230,255),
    "purple" : (128, 0, 128,255),
    "red" : (255, 0, 0,255),
    "rosybrown" : (188, 143, 143,255),
    "royalblue" : (65, 105, 225,255),
    "saddlebrown" : (139, 69, 19,255),
    "salmon" : (250, 128, 114,255),


    "air" : (0,0,0,0),
    "aliceblue" : (240, 248, 255,255),
    "antiquewhite" : (250, 235, 185,255),
    "aquamarine" : (127, 255, 212,255),
    "aqua" : (0, 255, 255,255),
    "arcticwhite" : (255, 252, 250,255),
    "azure" : (240, 255, 255,255),
    "bisque" : (255, 228, 196,255),
    "black" : (0, 0, 0,255),
    "blanchedalmond" : (255, 235, 205,255),
    "blue" : (0, 0, 255,255),
    "blueviolet" : (138, 43, 226,255),
    "brown" : (165, 42, 42,255),
    "burlywood" : (222, 184, 135,255),
    "cadetblue" : (95, 158, 160,255),
    "chartreuse" : (127, 255, 0,255),
    "chocolate" : (210, 105, 30,255),
    "coral" : (255, 127, 80,255),
    "cornsilk" : (255, 248, 220,255),
    "crimson" : (220, 20, 60,255),
    "cyan" : (0, 255, 255,255),
    "darkblue" : (0, 0, 139,255),
    "darkcyan" : (0, 139, 139,255),
    "darkgoldenrod" : (220, 135, 43,255),
    "darkgray" : (169, 169, 169,255),
    "darkgreen" : (0, 100, 0,255),
    "darkkhaki" : (189, 183, 107,255),
    "darkmagenta" : (60, 0, 120,255),
    "darkorange" : (255, 140, 0,255),
    "darkorchid" : (153, 50, 204,255),
    "darkred" : (192, 0, 48,255),
    "darksalmon" : (233, 150, 122,255),
    "darkseagreen" : (143, 188, 143,255),
    "darkslateblue" : (72, 61, 139,255),
    "darkslategray" : (47, 79, 79,255),
    "darkturquoise" : (64, 207, 204,255),
    "darkviolet" : (148, 0, 211,255),
    "deeppink" : (255, 20, 147,255),
    "deepskyblue" : (0, 191, 255,255),
    "dimgray" : (105, 105, 105,255),
    "dodgerblue" : (30, 144, 255,255),
    "firebrick" : (228, 34, 34,255),
    "floralwhite" : (255, 250, 240,255),
    "fuchsia" : (255, 0, 255,255),
    "gainsboro" : (220, 220, 220,255),
    "ghostwhite" : (255, 248, 240,255),
    "gold" : (255, 215, 0,255),
    "goldenrod" : (218, 165, 32,255),
    "gray" : (128, 128, 128,255),
    "green" : (0, 128, 0,255),
    "honeydew" : (240, 255, 240,255),
    "hotpink" : (255, 105, 180,255),
    "indianred" : (205, 92, 92,255),
    "indigo" : (75, 0, 130,255),
    "ivory" : (255, 250, 220,255),
    "jade" : (61, 205, 50,255),
    "khaki" : (240, 230, 140,255),
    "lavender" : (230, 230, 250,255),
    "lavenderblush" : (255, 240, 245,255),
    "lemonchiffon" : (255, 250, 205,255),
    "lightblue" : (175, 216, 230,255),
    "lightcoral" : (240, 128, 128,255),
    "lightcyan" : (224, 255, 255,255),
    "lightgoldenrod" : (250, 250, 210,255),
    "lightgray" : (211, 211, 211,255),
    "lightgreen" : (144, 238, 144,255),
    "lightpink" : (255, 182, 193,255),
    "lightsalmon" : (255, 160, 122,255),
    "lightseagreen" : (32, 178, 170,255),
    "lightskyblue" : (135, 206, 225,255),
    "lightslategray" : (211, 211, 211,255),
    "lightslategrey" : (211, 211, 211,255),
    "lightsteelblue" : (196, 224, 230,255),
    "lightyellow" : (255, 255, 224,255),
    "lime" : (0, 255, 0,255),
    "limegreen" : (0, 255, 128,255),
    "linen" : (255, 250, 220,255),
    "magenta" : (255, 0, 255,255),
    "maroon" : (128, 0, 0,255),
    "mediumaquamarine" : (102, 205, 170,255),
    "mediumblue" : (205, 0, 0,255),
    "mediumorchid" : (186, 85, 211,255),
    "mediumpurple" : (147, 112, 219,255),
    "mediumseagreen" : (60, 179, 140,255),
    "mediumslateblue" : (123, 104, 238,255),
    "mediumspringgreen" : (0, 250, 154,255),
    "mediumturquoise" : (72, 209, 204,255),
    "mediumvioletred" : (199, 21, 133,255),
    "midnightblue" : (25, 25, 112,255),
    "mintcream" : (245, 250, 235,255),
    "mistyrose" : (255, 228, 225,255),
    "moccasin" : (255, 228, 196,255),
    "navajowhite" : (255, 222, 173,255),
    "navy" : (0, 0, 128,255),
    "oldlace" : (255, 230, 230,255),
    "olive" : (128, 128, 0,255),
    "orange" : (255, 165, 0,255),
    "orangered" : (255, 69, 0,255),
    "orchid" : (218, 112, 214,255),
    "palegoldenrod" : (250, 250, 220,255),
    "palegreen" : (152, 251, 152,255),
    "paleturquoise" : (64, 224, 208,255),
    "palevioletred" : (219, 112, 133,255),
    "peachpuff" : (255, 218, 185,255),
    "peru" : (205, 133, 63,255),
    "pink" : (255, 192, 203,255),
    "plum" : (221, 160, 221,255),
    "powderblue" : (176, 224, 230,255),
    "purple" : (160, 32, 144,255),
    "red" : (255, 0, 0,255),
    "rosybrown" : (188, 143, 143,255),
    "royalblue" : (65, 105, 225,255),
    "saddlebrown" : (222, 114, 44,255),
    "salmon" : (250, 128, 114,255),
    "sandybrown" : (244, 164, 96,255),
    "seagreen" : (46, 139, 87,255),
    "seashell" : (255, 245, 238,255),
    "sienna" : (160, 82, 45,255),
    "silver" : (192, 192, 192,255),
    "skyblue" : (135, 206, 235,255),
    "slateblue" : (106, 90, 205,255),
    "slategray" : (112, 128, 144,255),
    "slategrey" : (112, 128, 144,255),
    "snow" : (255, 250, 250,255),
    "springgreen" : (0, 255, 127,255),
    "steelblue" : (70, 130, 180,255),
    "tan" : (210, 180, 140,255),
    "teal" : (0, 128, 128,255),
    "thistle" : (216, 191, 216,255),
    "tomato" : (255, 99, 71,255),
    "turquoise" : (64, 224, 208,255),
    "violet" : (238, 130, 238,255),
    "wheat" : (245, 222, 179,255),
    "white" : (255, 255, 255,255),
    "whitesmoke" : (245, 245, 245,255),
    "yellow" : (255, 255, 0,255),
    "yellowgreen" : (154, 205, 50,255),

    #my colors

    "delta_blue" : (150, 150, 200,255),
    "delta_blue_faded" : (150, 150, 200,170),
    "black_faded" : (0,0,0,180),
    "red_fight" : (200,20,20,255),
    "red_fight_faded" : (200,20,20,170),
    "delta_lightblue" : (175, 175, 225,255),
    "delta_purple" : (102, 102, 153,255),
    "F" : (255,255,255,255),
    "D" : (100, 200, 255,255),
    "C" : (156, 204, 101,255),
    "B" : (255, 112, 67,255),
    "A" : (255, 202, 40,255),
    "S" : (209, 196, 233,255),
    "X" : (0, 0, 0,255),
    "noodle" : (238,192,124,255),
    "water" : (0,71,214,255),
    "clearwater" : (65,196,216,255),

}



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/getsave.py


"""""
CODED by deltasfer
enjoy
programme sauvegarde de fichiers sources
"""""

# va de pair avec getback v3

version = 3

import os

def save_files(bigpath,path = ['/.','/src'],save_path = '/autosav/'):



    autosav = ''

    for chem in path:
        #print('path',bigpath+chem,':',os.listdir(bigpath+chem))
        try:
            for file in os.listdir(bigpath+chem):
                if file[-3:] == '.py':
                    autosav += '\n\n\n _newfile_ :' + bigpath+chem+'/'+file + '\n\n\n'
                    with open(bigpath+chem+'/'+file,'r') as f:
                        autosav += f.read()
        except :
            jsghd=0
            #print('no path',bigpath+chem,':',os.listdir(bigpath+chem))

    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
        version[1]+=1
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])
    except:
        os.makedirs(bigpath+save_path)
        with open(bigpath+save_path+'version','w') as f:
            f.write(version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

    ### POSITIONNE LE CHEMIN POUR SAV

    #saved_path = None

    pc_name = os.environ['COMPUTERNAME']

    #print(pc_name)

    if pc_name == 'DELTAPC':

        name = os.path.basename(bigpath)
        if name not in os.listdir('Z:\\DESKTOP\\CODING\\SAV'):
            os.makedirs('Z:\\DESKTOP\\CODING\\SAV\\'+name)
        save_path = 'SAV\\'+name+'\\'
        bigpath = 'Z:\\DESKTOP\\CODING\\'

    elif pc_name == 'DELTADELL':

        name = os.path.basename(bigpath)
        if name not in os.listdir('C:\\CODING\\SAV'):
            os.makedirs('C:\\CODING\\SAV\\'+name)
        save_path = 'SAV\\'+name+'\\'
        bigpath = 'C:\\CODING\\'

    saved_path = bigpath + save_path

    with open(saved_path+'saved_'+version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]+'.savd','w') as f:
        f.write(autosav)

    if pc_name in ['DELTADELL','DELTAPC']:
        print('files saved on',saved_path+', version',version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])
    else:
        print('files saved locally, version',version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:])

def get_version(bigpath,save_path = '/autosav/'):
    version = ['alpha',10001]

    try:
        with open(bigpath+save_path+'version','r') as f:
            tab = f.read().split('_')
            version = [tab[0],int(tab[1])*10000+int(tab[2])]
    except:
        a=0
    return version[0]+'_'+str(version[1])[0]+'_'+str(version[1])[-4:]



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/graphic.py


"""
CODED by deltasfer
enjoy
"""

import pyglet,random,time
from math import *
import src.utils as u
from src import obj as o
from src.colors import *
from colors import *

import pyglet.gl as gl


'''''''''''''''''''''''''''''''''''''''
'''''''PART ONE : GRAPHIC STUFF''''''''
'''''''''''''''''''''''''''''''''''''''


SPR = 32
FPS = 0
SAFE_W = 500

class ScreenManager():
    def __init__(self):

        self.display = pyglet.canvas.get_display()
        self.screens = self.display.get_screens()

        self.current_screen = self.screens[0]
        #print(dir(self.current_screen))

    def update_screen(self,window):
        if window.screen in self.screens:
            #print('yeaas screen bien dans screens')
            self.current_screen = window.screen

    def _screen(self):
        return self.current_screen
    screen = property(_screen)

    def _size(self):
        return self.screen.width,self.screen.height
    size = property(_size)

    def _w(self):
        return self.screen.width
    w = property(_w)
    def _h(self):
        return self.screen.height
    h = property(_h)

    def _x(self):
        return self.screen.x
    x = property(_x)
    def _y(self):
        return self.screen.y
    y = property(_y)


    def _cx(self):
        return self.screen.width/2
    cx = property(_cx)
    def _cy(self):
        return self.screen.height/2
    cy = property(_cy)
    def _cxy(self):
        return self.cx,self.cy
    cxy = property(_cxy)


    def _fx(self):
        return self.x+self.w
    fx = property(_fx)
    def _fy(self):
        return self.y+self.h
    fy = property(_fy)
    def _fxy(self):
        return self.fx,self.fy
    fxy = property(_fxy)


    def _c(self):
        return self.cx,self.cy
    c = property(_c)

scr = ScreenManager()

#manager who rules groups to draw things in the right order u know
class GroupManager():

    def __init__(self):


        self.groups = {} ## give the group with the name

        self.names_wo = {} ## give the name with the order
        self.orders = {} ## give the order with the name

        self.nb_perso_group = 20

        names = ['sky','stars','moon_sun','bg_buildings_loin','bg_buildings_proche','sbahn','road','buildings','backstreet','backstreet_anim','mid' # good
                            ,'front','perso-1','hud-1','hud','hud1']
        names += ['persoup','persoup_weapon','persoup_arm']
        #names += ['perso'+str(i) for i in range(self.nb_perso_group-1,-1,-1)]

        for i in range(self.nb_perso_group-1,-1,-1):
            k = str(i)
            if len(k) == 1:
                k = '0'+k
            s = 'perso'+k
            names += [s,s+'_weapon',s+'_arm']

        names += ['persodown','persodown_weapon','persodown_arm']
        names += ['frontstreet','frontstreet_anim','hud2-1','hud2','hud21','hud22','hud3','ui-2','ui-1','ui','up-1','up']
        self.distance_btw = 1

        for i in range(len(names)):
            self.addGroup(names[i],i*self.distance_btw)

        #print(dir(self.groups['sky']))

    def getGroup(self,name=None,order=None):

        if name and name in self.groups:
            return self.groups[name]

        elif order and order in self.names_wo:
            return getGroup(self.names_wo[order])

        print('aie le groupe',(name,order),'n\'existe pas')

    def order(self,name=None,group=None):

        if name and name in self.groups:
            return self.groups[name].order

        elif group:
            return group.order

        print('aie le groupe '+name+' n\'existe pas')

    def name(self,order):
        if order and order in self.names_wo:
            return self.names_wo[order]

        print('aie le groupe',order,'n\'existe pas')

    def addGroup(self,name,order):
        if not name in self.groups:
            self.groups[name] = pyglet.graphics.OrderedGroup(order)
            self.orders[name] = order
            self.names_wo[order] = name
            return self.groups[name]
        return self.groups[name] # group was already created

#manager who init images
class TextureManager():

    def __init__(self,path='.'):

        self.textures = {}

        self.path = path

        self.ids = []

        self.batch = pyglet.graphics.Batch()

    def loadImSeq(self,path2,size,scale=None):

        # size décrit le nb de tiles en w et en h

        path3 = '/item/'
        img = pyglet.image.load(self.path+path3+path2)

        textures = pyglet.image.ImageGrid(img, *size)

        ids = []
        for txt in textures:
            id = u.get_id('text')
            self.textures[id] = txt

            self.ids.append(id)
            ids.append(id)
        return ids

    def loadIm(self,path2,scale=None):

        path3 = '/item/'
        id = u.get_id('img')
        img = pyglet.image.load(self.path+path3+path2)

        self.textures[id] = img
        self.ids.append(id)
        return id

    def addText(self,text):
        id = u.get_id('img')
        self.textures[id] = text
        self.ids.append(id)
        return id

    def addCol(self,color='white',w=SPR,h=SPR):

        if color not in TEXTIDS['col']:
            pattern = pyglet.image.SolidColorImagePattern(c[color])
            id = u.get_id('col')
            self.textures[id] = pattern.create_image(w,h)
            self.ids.append(id)
            TEXTIDS['col'][color] = id
            return id
        else:
            return TEXTIDS['col'][color]

    def draw(self):


        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST)
        self.batch.draw()
        #print(len(sman.sprites))#,'    ',sman.ids)

tman,gman = TextureManager(),GroupManager()

#manager who rules normal sprites
class SpriteManager():

    def __init__(self):

        ## SPRITES

        self.sprites = {}

        self.ids = []

        self.filters = {}

    def addSpr(self,textid,xy_pos=(0,0),group=None,id=None,vis=True,wh=None,anchor=None,rota=None,key='spr'):

        if not id:
            id = u.get_id(key)

        if id not in self.ids:
            self.ids.append(id)

        self.sprites[id] = pyglet.sprite.Sprite(tman.textures[textid], batch=tman.batch)
        self.sprites[id].position = xy_pos
        self.sprites[id].visible = vis

        #if wh and (self.sprites[id].width != wh[0] or self.sprites[id].height != wh[1]):
        self.modify(id,size=wh,anchor=anchor,rota=rota)

        if group != None:
            self.addToGroup(id,group)

        return id

    def addCol(self,col='white',box=u.box(),group=None,id=None,vis=True,key='col'):
        if col in TEXTIDS['col']:
            return self.addSpr(TEXTIDS['col'][col],box.xy,group,id,vis,wh=box.wh,key=key)
        else:
            tman.addCol(col)
            return self.addCol(col,box,group,id,vis)

    def addCircle(self,pos,ray,col=(255,255,255,255),group=None,alr_id=-1,vis=True):

        if alr_id == -1:
            id = u.get_id('spr')
            self.ids.append(id)
        else:
            id =alr_id

        if group != None:
            group = gman.getGroup(group)

        x,y = pos
        opac = col[3]
        col = col[0],col[1],col[2]
        self.sprites[id] = pyglet.shapes.Circle(x,y,ray,color=col,batch=tman.batch,group=group)
        self.sprites[id].opacity = opac
        self.sprites[id].visible = vis

        return id

    def addToGroup(self,id,group_name='bg_buildings_loin'):

        group = gman.getGroup(group_name)
        self.sprites[id].group = group

        #self.detect()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                if self.sprites[id].visible != (not hide):
                    self.sprites[id].visible = (not hide)

        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)

        else:
            if self.sprites[tabids].visible != (not hide):
                self.sprites[tabids].visible = (not hide)

    def set_text(self,sprid,textid):
        if sprid in self.sprites and textid:

            if self.sprites[sprid].image != tman.textures[textid]:
                self.sprites[sprid].image = tman.textures[textid]

    def get_text(self,sprid):
        if sprid in self.sprites:
            return list(tman.textures.keys())[list(tman.textures.values()).index(self.sprites[sprid].image)]

    def modify(self,sprid,pos=None,scale=None,group=None,rota=None,opacity=None,anchor=None,size=None):

        # position
        x,y = None,None
        if pos != None and pos != (self.sprites[sprid].x,self.sprites[sprid].y):
            x,y = pos

        # scale
        scalex,scaley = None,None
        if scale != None and scale != (self.sprites[sprid].scale_x,self.sprites[sprid].scale_y):
            scalex,scaley = scale

        # size
        if size != None:
            w,h = size
            if w != None and w != self.sprites[sprid].width:
                ow = self.sprites[sprid].width/self.sprites[sprid].scale_x
                scalex = w/ow
            if h != None and h != self.sprites[sprid].height:
                oh = self.sprites[sprid].height/self.sprites[sprid].scale_y
                scaley = h/oh

        # updating group
        if group != None:
            group = gman.getGroup(group)
            if group != self.sprites[sprid].group:
                self.sprites[sprid].group = group

        # updating opacity
        if opacity != None:
            if opacity != self.sprites[sprid].opacity:
                self.sprites[sprid].opacity = opacity

        # final updating positon and scale
        #
        self.sprites[sprid].update(x=x,y=y,rotation=rota,scale_x = scalex,scale_y=scaley)

        if anchor:
            if type(anchor) != type('wesh'):
                ancx,ancy = anchor
                x,y = self.sprites[sprid].position
                if ancx and ancx == 'center':
                    x -= self.sprites[sprid].width/2
                elif ancx and ancx == 'right':
                    x -= self.sprites[sprid].width


                if ancy and ancy == 'center':
                    y -= self.sprites[sprid].height/2
                elif ancy and ancy == 'top':
                    y -= self.sprites[sprid].height

                self.sprites[sprid].update(x=x,y=y)

            elif anchor == 'center':
                x,y = self.sprites[sprid].position
                x -= self.sprites[sprid].width/2
                y -= self.sprites[sprid].height/2
                self.sprites[sprid].update(x=x,y=y)

    def flip(self,id,dirx=1,diry=1):
        if id in self.sprites:
            scx = self.sprites[id].scale_x
            if dirx == 1 and scx < 0:
                self.sprites[id].update(scale_x = -scx,rotation=-self.sprites[id].rotation)
            elif dirx == -1 and scx > 0:
                self.sprites[id].update(scale_x = -scx,rotation=-self.sprites[id].rotation)

    def set_col(self,sprid,col):
        if col in TEXTIDS['col']:
            w,h = self.sprites[sprid].width,self.sprites[sprid].height
            self.set_text(sprid,TEXTIDS['col'][col])
            self.modify(sprid,scale=(1,1))
            sc = w/self.sprites[sprid].width,h/self.sprites[sprid].height
            self.modify(sprid,scale=sc)
        else:
            tman.addCol(col)
            self.set_col(sprid,col)

    #filter
    def filter(self,sprid,color=(255,0,0)):

        if type(sprid) == type([]):
            for id in sprid:
                self.filter(id,color)

        elif type(sprid) == type({}):
            for id in sprid:
                self.filter(sprid[id],color)
        else:
            self.sprites[sprid].color = color

    def update_filter(self,sprid):

        if sprid in self.filters and len(self.filters[sprid]) != 0:

            #print('debut :',self.filters[sprid])
            r,g,b = 0,0,0
            tot_st = 0

            for filterid in self.filters[sprid]:
                col,st = self.filters[sprid][filterid]
                r+=col[0]*st
                g+=col[1]*st
                b+=col[2]*st
                tot_st += st

            moy_st = tot_st/len(self.filters[sprid])
            r/=tot_st
            g/=tot_st
            b/=tot_st

            final_color = (255-r*moy_st,255-g*moy_st,255-b*moy_st)
            #print('fin :',final_color)
            self.filter(sprid,final_color)

    def add_filter(self,sprid,color=(0,255,255),strengh=1,filterid='hit'):

        ### ATTENTION !! POUR LES FILTRES IL FAUT ENVOYER LA COULEUR INVERSE
        ## on veut du rouge à l'écran ? add_filter( (0,255,255) )

        if sprid not in self.filters:
            self.filters[sprid] = {}
        self.filters[sprid][filterid] = (color,strengh)
        self.update_filter(sprid)

    def del_filter(self,sprid,filterid='hit'):
        if sprid in self.filters and filterid in self.filters[sprid]:
            del self.filters[sprid][filterid]
            if len(self.filters[sprid]) == 0:
                del self.filters[sprid]
            else:
                self.update_filter(sprid)
        self.filter(sprid,(255,255,255))

    def spr(self,id):
        if id in self.sprites:
            return self.sprites[id]
        return None

    def realbox(self,id):
        spr = self.sprites[id]
        return [spr.x,spr.y,spr.x+spr.width,spr.y+spr.height]

    def box(self,id):
        spr = self.sprites[id]
        return u.box(spr.x,spr.y,spr.width,spr.height)

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les sprites affichés ingame
            for id in self.sprites:
                self.sprites[id].delete()
            self.sprites = {}
            #print('sprites deleted')

        elif type(tabids) == type('aa'): # on delete un seul sprite precis
            if tabids in self.sprites:
                self.sprites[tabids].delete()
                del self.sprites[tabids]
                #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de sprite
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de sprite
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

    def __str__(self):

        s = ''
        for id in self.sprites:
            s += id + ' --- ' + str(self.sprites[id].group) + '\n'
        return s

#manager who rules normal labels
class LabelManager():

    def __init__(self,fonts=None):

        if fonts != None:
            self.fonts = fonts
            self.font = fonts[0]
        else:
            self.fonts = ['arial']
            self.font = 'arial'
        ## RaubFont

        self.labels = {}
        self.ids = []

    def updateman(self,fonts=None):

        if fonts != None:
            self.fonts = fonts
            self.font = fonts[0]
        else:
            self.fonts = ['arial']
            self.font = 'arial'

    def addLab(self,contenu,xy_pos=(0,0),alr_id=-1,vis=True,font_name=None,font_size=30,group='hud'
                ,anchor = ('left','bottom'),color=(255,255,255,255),use_str_bien=False,w=20):

        if alr_id == -1:
            id = u.get_id('lbl')
            self.ids.append(id)
        else:
            id =alr_id

        if font_name == None:
            font_name = self.font
        elif type(font_name) == int:
            font_name = self.fonts[font_name]

        if type(contenu) != type('qsd'):
            contenu = str(contenu)

        if use_str_bien:
            contenu = u.str_bien(contenu,w)

        multi = '\n' in contenu

        anchor_x,anchor_y= anchor

        if multi:
            width = 4000
            anchor_x = 'center'
        else:
            width = None

        if group != None:
            group = gman.getGroup(group)
        self.labels[id] = pyglet.text.Label(contenu,font_name=font_name,font_size=font_size,group=group, \
                        batch=tman.batch,anchor_x= anchor_x,anchor_y= anchor_y,color=color,multiline=multi,width=width,align='center')



        self.labels[id].x,self.labels[id].y = xy_pos
        self.unhide(id,not vis)
        #self.labels[id].visible = vis


        return id

    def addToGroup(self,id,thg=['bg_buildings_loin',None],thg2=0,level_to_put_in=0):

        group = gman.createGroup(thg,thg2,level_to_put_in)
        #print('GROUP IS',group)
        self.labels[id]._init_groups(group)
        self.labels[id]._update()

    def unhide(self,tabids,hide=False):
        ## unhide(machin) AFFICHE machin
        ## unhide(machin,True) N'AFFICHE PAS machin

        if type(tabids) == type([]):
            for id in tabids:
                self.unhide(id,hide)
        elif type(tabids) == type({}):
            for id in tabids:
                self.unhide(tabids[id],hide)
        else:
            if hide == False and self.labels[tabids].color[3] == 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],255]
            elif hide == True and self.labels[tabids].color[3] != 0:
                self.labels[tabids].color = [*self.labels[tabids].color[:3],0]

    def set_text(self,lblid,contenu):

        if type(contenu) != type('qsdd'):
            contenu = str(contenu)

        if self.labels[lblid].text != contenu:
            self.labels[lblid].text = contenu

    def printGroup(self,lblid):
        print('\ttopgroup :',self.labels[lblid].top_group)
        print('\tbackgroup :',self.labels[lblid].background_group)
        print('\tforegroup :',self.labels[lblid].foreground_group)
        print('\tforegroupdeco :',self.labels[lblid].foreground_decoration_group)

    def modify(self,lblid,pos=None,size=None,scale=None,color=None,group=None):

        if scale != None :
            newsize = self.labels[lblid].font_size*scale
            self.labels[lblid].font_size = int(newsize)

        if size != None:
            self.labels[lblid].font_size = size

        if pos != None:
            if pos[0] != None and pos[0] != self.labels[lblid].x:
                self.labels[lblid].x = pos[0]
            if pos[1] != None and pos[1] != self.labels[lblid].y:
                self.labels[lblid].y = pos[1]

        if color != None and color != self.labels[lblid].color:
            self.labels[lblid].color = color

        # updating group
        if group != None:
            group = gman.getGroup(group)
            if group != self.labels[lblid].top_group.parent:
                #print(group,self.labels[lblid].top_group.__dict__)
                self.labels[lblid]._init_groups(group)
                self.labels[lblid]._update()

    def delete(self,tabids='all'):

        if tabids == 'all': # on delete tous les labels affichés ingame
            for id in self.labels:
                self.labels[id].delete()
            self.labels = {}
            #print('labels deleted')

        elif type(tabids) == type('aa'): # on delete un seul label precis
            self.labels[tabids].delete()
            del self.labels[tabids]
            #print(tabids,'deleted')

        elif type(tabids) == type([]): # on delete un tableau de label
            #print('deleting',tabids)
            for id in tabids:
                self.delete(id)

        elif type(tabids) == type({}): # on delete un dico de label
            #print('deleting',tabids)
            for lab in tabids:
                self.delete(tabids[lab])

sman,lman = SpriteManager(),LabelManager()

class ParticleManager():

    def __init__(self):
        self.sprites = {}
        self.sprites['normal'] = {}
        self.sprites['steam'] = {}
        self.sprites['steam2'] = {}
        self.sprites['bullet'] = {}

        self.labels = {}
        self.labels['normal'] = {}
        self.labels['icons'] = {}
        self.labels['dmg'] = {}
        self.labels['say'] = {}
        self.labels['cmd'] = {}

        self.part = {}
        for cat in list(self.sprites.keys()) + list(self.labels.keys()):
            self.part[cat] = {}

    def addPart(self,textid,xy_pos=(0,0),duree=5,group='ui',key='normal',opac=255,vis=True):

        id = u.get_id('spr_part')
        #self.ids.append(id)
        x,y = xy_pos

        self.sprites[key][id] = pyglet.sprite.Sprite(tman.textures[textid], batch=tman.batch)
        self.sprites[key][id].visible = vis
        self.sprites[key][id].position = xy_pos
        self.sprites[key][id].opacity = opac
        self.part[key][id] = {'x':x,'y':y}

        if group != None:
            group = gman.getGroup(group)
            self.sprites[key][id].group = group

        if duree:
            bertran.schedule_once(self.delay_spr,duree*0.01,id,key)

        return key,id

    def addLabPart(self,contenu,xy_pos=(0,0),duree=5,font_name=None,font_size=20,group=None,anchor = \
                ('center','center'),color=(255,255,255,255),key='normal',vis=True,use_str_bien=True,w=20):

        id = u.get_id('lab_part')

        if font_name == None:
            font_name = lman.font
        elif type(font_name) == int:
            font_name = lman.fonts[font_name]

        if type(color) == type('wesh'):
            color = c[color]
        if not vis:
            color = [*color[:3],0]


        if type(contenu) != type('qsd'):
            contenu = str(contenu)

        if use_str_bien:
            contenu = u.str_bien(contenu,w)

        multi = '\n' in contenu

        anchor_x,anchor_y= anchor

        if multi:
            width = 2000
            anchor_x = 'center'
        else:
            width = None


        if group != None:
            group = gman.getGroup(group)
        self.labels[key][id] = pyglet.text.Label(contenu,font_name=font_name,font_size=font_size,group=group, \
                        batch=tman.batch,anchor_x= anchor_x,anchor_y= anchor_y,color=color,multiline=multi,align='center',width=width)

        self.labels[key][id].x,self.labels[key][id].y = xy_pos
        x,y = xy_pos
        self.part[key][id] = {'x':x,'y':y}

        if duree:
            bertran.schedule_once(self.delay_lab,duree*0.01,id,key)
        return key,id

    def addCol(self,col='white',box=u.box(),duree=5,group=None,key='normal'):
        ## not optimized so plz correct it
        text = tman.addCol(col)
        key,id = self.addPart(text,box.xy,duree,group,key)

        scalex,scaley = None,None
        w,h = box.wh
        if w != self.sprites[key][id].width:
            ow = self.sprites[key][id].width/self.sprites[key][id].scale_x
            scalex = w/ow
        if h != self.sprites[key][id].height:
            oh = self.sprites[key][id].height/self.sprites[key][id].scale_y
            scaley = h/oh
        self.sprites[key][id].update(scale_x = scalex,scale_y=scaley)

        return key,id

    def alert(self,*cont):
        xy_pos = scr.cx,3*scr.cy/2
        color = (255,20,20,255)
        duree = 10
        size = 40
        self.addLabPart(' '.join(cont),xy_pos,duree,font_size=size,color=color,group='ui',use_str_bien=False)

    def delay_spr(self,dt,id,key):

        #print(id)
        self.sprites[key][id].opacity = self.sprites[key][id].opacity-(0.1*255)
        if self.sprites[key][id].opacity <= 0:
            self.sprites[key][id].delete()
            del self.sprites[key][id]
        else:
            bertran.schedule_once(self.delay_spr,dt,id,key)

    def delay_lab(self,dt,id,key):

        if key in self.labels and id in self.labels[key]:
            self.labels[key][id].color = (*self.labels[key][id].color[:3]  , int(self.labels[key][id].color[3]-(0.1*255)))
            if self.labels[key][id].color[3] <= 0:
                self.labels[key][id].delete()
                del self.labels[key][id]
            else:
                bertran.schedule_once(self.delay_lab,dt,id,key)

    def modify(self,key,dx=None,dy=None,setx=None,sety=None,ux=None,uy=None):
        if key in self.sprites:
            for id in self.sprites[key]:
                if setx:
                    self.sprites[key][id].x = setx
                    #self.part[key][id]['x'] = setx #broken
                elif dx:
                    self.sprites[key][id].x += dx
                    self.part[key][id]['x'] += dx
                elif ux:
                    self.sprites[key][id].x = self.part[key][id]['x'] + ux

                if sety:
                    self.sprites[key][id].y = sety
                    #self.part[key][id]['y'] = sety
                elif dy:
                    self.sprites[key][id].y += dy
                    self.part[key][id]['y'] += dy
                elif uy:
                    self.sprites[key][id].y += self.part[key][id]['y'] + uy

        else:
            for id in self.labels[key]:
                if setx:
                    self.labels[key][id].x = setx
                    #self.part[key][id]['x'] = setx
                elif dx:
                    self.labels[key][id].x += dx
                    self.part[key][id]['x'] += dx
                elif ux:
                    self.labels[key][id].x = self.part[key][id]['x'] + ux

                if sety:
                    self.labels[key][id].y = sety
                    #self.part[key][id]['y'] = sety
                elif dy:
                    self.labels[key][id].y += dy
                    self.part[key][id]['y'] += dy
                elif uy:
                    self.labels[key][id].y += self.part[key][id]['y'] + uy

    def modify_single(self,keyid,dx=None,dy=None,setx=None,sety=None,ux=None,uy=None):
        key,id = keyid
        if key in self.labels and id in self.labels[key]:
            if setx:
                self.labels[key][id].x = setx
            elif dx:
                self.labels[key][id].x += dx
                self.part[key][id]['x'] += dx
            elif ux:
                self.labels[key][id].x = self.part[key][id]['x'] + ux

            if sety:
                self.labels[key][id].y = sety
            elif dy:
                self.labels[key][id].y += dy
                self.part[key][id]['y'] += dy
            elif uy:
                self.labels[key][id].y += self.part[key][id]['y'] + uy

        elif key in self.sprites and id in self.sprites[key]:
            if setx:
                self.sprites[key][id].x = setx
            elif dx:
                self.sprites[key][id].x += dx
                self.part[key][id]['x'] += dx
            elif ux:
                self.sprites[key][id].x = self.part[key][id]['x'] + ux

            if sety:
                self.sprites[key][id].y = sety
            elif dy:
                self.sprites[key][id].y += dy
                self.part[key][id]['y'] += dy
            elif uy:
                self.sprites[key][id].y += self.part[key][id]['y'] + uy

        if key == 'bullet' and ux == None:
            return
            #self.modify_single(keyid,ux=Cam.X+ GodCam.X)
            print(self.sprites[key][id].x,self.part[key][id])
    def unhide(self,key,hide=False):
        if key in self.sprites:
            for id in self.sprites[key]:
                if self.sprites[key][id].visible != (not hide):
                    self.sprites[key][id].visible = (not hide)
        else:
            for id in self.labels[key]:
                if hide == False and self.labels[key][id].color[3] == 0:
                    self.labels[key][id].color = [*self.labels[key][id].color[:3],255]
                elif hide == True and self.labels[key][id].color[3] != 0:
                    self.labels[key][id].color = [*self.labels[key][id].color[:3],0]

    def unhide_single(self,keyid,hide=False):
        key,id = keyid
        if key in self.sprites and id in self.sprites[key]:
            if self.sprites[key][id].visible != (not hide):
                self.sprites[key][id].visible = (not hide)

        elif key in self.labels and id in self.labels[key]:
            if hide == False and self.labels[key][id].color[3] == 0:
                self.labels[key][id].color = [*self.labels[key][id].color[:3],255]
            elif hide == True and self.labels[key][id].color[3] != 0:
                self.labels[key][id].color = [*self.labels[key][id].color[:3],0]

    def delete(self,keyid):
        key,id = keyid
        if key in self.labels and id in self.labels[key]:
            self.labels[key][id].delete()
            del self.labels[key][id]
            del self.part[key][id]

        elif key in self.sprites and id in self.sprites[key]:
            self.sprites[key][id].delete()
            del self.sprites[key][id]
            del self.part[key][id]

    def spr_lab(self,keyid):
        #print(keyid)
        key,id = keyid
        if key in self.labels and id in self.labels[key]:
            return self.labels[key][id]

        elif key in self.sprites and id in self.sprites[key]:
            return self.sprites[key][id]

pman = ParticleManager()
def alert(*args): pman.alert(*args)


TEXTIDS = {}
TEXTIDS['col'] = {}

def print_groups():

    print('\nYOU ASKED TO PRINT GROUPS AND THEIR ORGANISATION:')
    print('  will be displayed in descending order like that : order,name\n')

    tab = []
    orders_sorted = sorted(gman.names_wo,reverse=True)
    print(orders_sorted,gman.names_wo)

    for order in orders_sorted:
        say = str(order)
        say += (6-len(say))*' '
        say +=gman.names_wo[order]

        # nb spr
        if True:
            nb_spr = 0
            for id in sman.sprites:
                spr = sman.sprites[id]
                if spr.group.order == order:
                    nb_spr += 1

            if nb_spr > 0:
                say+= cyan('  -- '+str(nb_spr)+' sprites')
        # nb lab
        if True:
            nb_lab = 0
            for id in lman.labels:
                lab = lman.labels[id]
                if lab.top_group.parent.order == order:
                    nb_lab += 1

            if nb_lab > 0:
                say+= magenta('  -- '+str(nb_lab)+' labels')
        # nb part-spr / part-lab
        if True:
            nb_spr = 0
            for grp in pman.sprites:
                for id in pman.sprites[grp]:
                    spr = pman.sprites[grp][id]
                    if spr.group.order == order:
                        nb_spr += 1
            nb_lab = 0
            for grp in pman.labels:
                for id in pman.labels[grp]:
                    lab = pman.labels[grp][id]
                    if lab.top_group.parent.order == order:
                        nb_lab += 1

            if nb_lab > 0 or nb_spr > 0:
                say += green('  -- ')
                if nb_spr > 0:
                    say+= cyan(str(nb_spr))
                if nb_spr > 0 and nb_lab > 0:
                    say+= green('/')
                if nb_lab > 0:
                    say+= magenta(str(nb_lab))
                say += green(' particles')

        print(say)
    print('')


"""'''''''''''''''''''''''''''''''''
'''''''PART 2 : ANIM      ''''''''''
'''''''''''''''''''''''''''''''''"""


class Anim():

    def __init__(self,id,texts,times=None,loop=False):

        if not times:
            times = [0.05 for _ in texts]

        self.id = id
        if loop:
            self.text = sman.get_text(self.id)

        self.texts = texts
        self.times = times

        self.k = -1
        self.anim()
        self.running = True

    def set_id(self,id):
        self.id = id
        if self.k == len(self.texts) -1 and hasattr(self,'text'):
            sman.set_text(self.id,self.text)
        else:
            sman.set_text(self.id,self.texts[self.k])

    def anim(self,dt=0):

        self.k += 1
        #print(cyan('anim '+str(self.k)))

        sman.set_text(self.id,self.texts[self.k])

        dt = self.times[self.k]
        if self.k == len(self.texts) -1:
            bertran.schedule_once(self.finish,dt)
        else:
            bertran.schedule_once(self.anim,dt)

    def finish(self,dt):
        #print(cyan('finished'))

        if hasattr(self,'text'):
            sman.set_text(self.id,self.text)
        self.running = False

"""'''''''''''''''''''''''''''''''''
'''''''PART 3 : CCCC STUFF''''''''''
'''''''''''''''''''''''''''''''''"""

#### KEYS ->  Not graphic nor C but t'as capté ya un K ça passe

keys = []
longpress = {}
joystick = None
butt = {'A':0,
        'B':1,
        'X':2,
        'Y':3,
        'LB':4,
        'RB':5,


        'LJ':8, # left joystick
        'RJ':9, # right joystick
        }


#cooldown = 0.5

def cooldown_one(key,obj):
    cooldown = obj.cooldown
    if key in longpress:
        perc = (time.time()-longpress[key])/cooldown
        if perc > 1:
            longpress[key] = time.time()
        return perc

    return 0


#### CYCLE -> rules day/night cycle

MODE_COLOR = 1 ## 1 pour avoir des couleurs wtf et 0 pour la "réalité"
DUREE_DAY = 20*60
# duree d'une journée en secondes

class Hour():
    def __init__(self,h,m=0):
        self.h = h
        self.m = m

    def _hm(self):
        return self.h,self.m
    hm = property(_hm)

    def __sub__(self, other):

        dh = 0
        m = self.m-other.m
        if m < 0:
            dh -= abs(m)//60 +1
            m = 60 - (abs(m)%60)
        elif m >= 60:
            dh += abs(m)//60
            m = (abs(m)%60)

        h = self.h-other.h + dh
        if h < 0:
            h = 24 - (abs(h)%24)
        elif h >= 24:
            h = (abs(h)%60)

        return Hour(h,m)
    def __add__(self, other):

        dh = 0
        m = self.m+other.m
        if m < 0:
            dh -= abs(m)//60 +1
            m = 60 - (abs(m)%60)
        elif m >= 60:
            dh += abs(m)//60
            m = (abs(m)%60)

        h = self.h+other.h + dh
        if h < 0:
            h = 24 - (abs(h)%24)
        elif h >= 24:
            h = (abs(h)%60)

        return Hour(h,m)

    def __lt__(self,other):	#describes less than operator(<)
        h,m = other.hm
        if self.h < h:
            return True
        if self.h > h:
            return False
        if self.m < m:
            return True
        if self.m > m:
            return False
        return False
    def __le__(self,other):	#descries less than or equal to (<=)
        h,m = other.hm
        if self.h < h:
            return True
        if self.h > h:
            return False
        if self.m < m:
            return True
        if self.m > m:
            return False
        return True
    def __gt__(self,other):	#describes greater than (>)
        h,m = other.hm
        if self.h < h:
            return False
        if self.h > h:
            return True
        if self.m < m:
            return False
        if self.m > m:
            return True
        return False
    def __ge__(self,other):	#describes greater than or equal to (>=)
        h,m = other.hm
        if self.h < h:
            return False
        if self.h > h:
            return True
        if self.m < m:
            return False
        if self.m > m:
            return True
        return True
    def __eq__(self,other):	#describes equality operator(==)
        return self.hm == other.hm
    def __ne__(self,other): #describes not equal to operator(!=)
        return not self.hm == other.hm

class Cycle():

    def __init__(self):

        # general

        # longueur du cycle en secondes
        self.len = DUREE_DAY
        self.dt = 0.05 # dt avant chaque update

        self.tick = 0

        self.day = 1 # nb de jour

        self.plus_sprids = []

    def launch(self,perso,bg):

        self.perso = perso

        # sprites

        self.ext_sprids = bg # tableau contenant les ids des sprites à colorer et le pourcentage d'effectif que le cycle a sur lui
        # (plus ce pourcentage se rapporche de 1 plus ça va devenir noir)

        #self.plus_sprids = [] # pareil mais en bonus (ce tableau là va être modifié souvent)

        self.sprids = {} # en plus on crée un dic qui va contenir les spr controlés directement par le cycle : type soleil, lune, etoile et meme weather ?
        self.sprids['sun'] = sman.addSpr(TEXTIDS['sun'],(scr.w/2,0),'moon_sun',key='sun')
        sman.modify(self.sprids['sun'],scale=(0.75,0.75))
        self.sprids['moon'] = sman.addSpr(TEXTIDS['moon'],(scr.w/4,0),'moon_sun',key='moon')
        sman.modify(self.sprids['moon'],scale=(0.75,0.75))
        self.sprids['stars'] = sman.addSpr(TEXTIDS['stars'],(0,0),'stars',key='stars')
        sman.modify(self.sprids['stars'],scale=(0.75,0.75),opacity=0)

        #COLORS
        self.newteinte()

        self.ticked()

    def ticked(self,dt=0):

        self.tick += 1
        #print(self.tick)
        if self.tick*self.dt > self.day*self.len:
            if self.tick*self.dt > (self.day+1)*self.len:
                self.day = int((self.tick*self.dt)/self.len)-1
            self.day_update()
        elif self.tick*self.dt < (self.day-1)*self.len:
            if self.tick*self.dt < (self.day-2)*self.len:
                self.day = int((self.tick*self.dt)/self.len)+1
            self.day -= 1
        day_percentage = (self.tick*self.dt - (self.day-1)*self.len )/self.len
        #print(day_percentage)
        self.update(day_percentage)

        bertran.schedule_once(self.ticked,self.dt)

    def update(self,day_percentage):
        ## color
        p=day_percentage
        r,g,b = self.R(p),self.G(p),self.B(p)

        ## bg
        for id,prc in self.ext_sprids+self.plus_sprids:
            sman.add_filter(id,[255*r,255*g,255*b],prc,'env')

        ## sun
        ysun = p*4*scr.h-0.6*scr.h
        sman.modify(self.sprids['sun'],pos=(None,ysun))
        sman.add_filter(self.sprids['sun'],[255*r,255*g,255*b],1,'env')

        ## moon
        pm = p-0.5
        if pm < 0:
            pm = 1+pm
        ymoon = pm*4*scr.h-1.2*scr.h
        sman.modify(self.sprids['moon'],pos=(None,ymoon))
        sman.add_filter(self.sprids['moon'],[255*r,255*g,255*b],0.5,'env')

        ## stars
        if p >= 0.8:
            ps = (p-0.8)*5
            sman.modify(self.sprids['stars'],opacity=ps*255)
        elif p < 0.2:
            ps = (1-p-0.8)*5
            sman.modify(self.sprids['stars'],opacity=ps*255)
        else:
            sman.modify(self.sprids['stars'],opacity=0)

    def add_spr(self,spr):
        if spr not in self.plus_sprids:
            self.plus_sprids.append(spr)

    def del_spr(self,spr):
        if spr in self.plus_sprids:
            self.plus_sprids.remove(spr)

    def empty_plus(self):
        self.plus_sprids = []

    def day_update(self):

        #general
        self.day += 1
        self.perso.add_money(-10)
        o.distro.update()

        #teinte
        self.newteinte()

    def newteinte(self):

        self.rr = (random.random()-0.5)
        self.gg = (random.random()-0.5)
        self.bb = (random.random()-0.5)

        if not MODE_COLOR:
            self.rr*=0.1
            self.gg*=0.1
            self.bb*=0.1

        #print('nouvelle teinte :',(self.rr,self.gg,self.bb))

    def roll_mode(self):
        global MODE_COLOR
        MODE_COLOR = not MODE_COLOR
        self.newteinte()

    def tick_set(self,tick):
        self.tick = tick - 1
        self.ticked()

    #rgb
    def R(self,dayperc):
        p = (dayperc*2-1)**2
        p=p+self.rr
        if p <0:
            return 0
        return p
    def G(self,dayperc):
        p = 1-sin(dayperc*pi)
        p=p+self.gg
        if p <0:
            return 0
        return p
    def B(self,dayperc):
        if dayperc < 0.5:
            p=1-dayperc*2
        else:
            p=(dayperc-0.5)*2
        p=p+self.bb
        if p <0:
            return 0
        return p

    #min/hour
    def _hm(self):
        p = (self.tick*self.dt - (self.day-1)*self.len )/self.len
        hm = int(p*24*60)
        h = hm//60
        m = (hm%60)
        return h,m
    hm = property(_hm)

    def __lt__(self,hour):
        return Hour(*self.hm) < hour
    def __le__(self,hour):
        return Hour(*self.hm) <= hour
    def __gt__(self,hour):
        return Hour(*self.hm) > hour
    def __ge__(self,hour):
        return Hour(*self.hm) >= hour
    def __eq__(self,hour):
        return Hour(*self.hm) == hour
    def __ne__(self,hour):
        return Hour(*self.hm) != hour

    def __str__(self):
        # retourne l'heure actuelle
        p = (self.tick*self.dt - (self.day-1)*self.len )/self.len
        hm = int(p*24*60)
        h = hm//60
        m = (hm%60)

        strh = str(h)
        if len(strh) < 2:
            strh = '0' + strh
        strm = str(m)
        if len(strm) < 2:
            strm = '0' + strm

        return strh+' : '+strm

    def _tpd(self):
        #tick per day
        return self.len/self.dt
    tpd = property(_tpd)

Cyc = Cycle()

#### CLOCK

class Clock(pyglet.clock.Clock):

    def __init__(self):
        self.__time = 0
        self.speed = 1.0
        pyglet.clock.Clock.__init__(self, time_function=self.get_time)
        pyglet.clock.schedule(self.advance)

    def advance(self, time):
        self.__time += time * self.speed
        self.tick()

    def get_time(self):
        return self.__time

    def set_speed(self, dt=0, speed=1.0):
        self.speed = speed

bertran = Clock() # bertran c'est le S


#### CURSOR

M = [0,0]

class Cursor():

    def __init__(self):

        self.long_time = 0.5 #en secondes

        ##
        self.longbox = None
        self.start_time = None
        self.func = None

    def init(self,window,textures):

        self.window = window
        self.text = textures

        cursor = pyglet.window.ImageMouseCursor(tman.textures[self.text[1]],16,16)
        self.window.set_mouse_cursor(cursor)

    def start_long_press(self,box,func):

        if u.collisionAX(box.realbox,M) and self.start_time == None:

            self.longbox = box
            self.start_time = bertran.get_time()
            self.func = func

            #self.check_long_press(0,xy)
            bertran.schedule(self.check_long_press)

    def check_long_press(self,dt=0):

        #check si on a quitté le box:
        if not u.collisionAX(self.longbox.realbox,M):
            self.reset()
            return 0

        percentage = (bertran.get_time()-self.start_time)/self.long_time
        self.change_skin(percentage)
        #print(percentage)

        if percentage >= 1:
            print('applying',self.func.__name__)
            self.func() # on clique
            self.reset()

    def reset(self):
        bertran.unschedule(self.check_long_press)
        cursor = pyglet.window.ImageMouseCursor(tman.textures[self.text[1]],16,16)
        self.window.set_mouse_cursor(cursor)
        self.longbox = None
        self.start_time = None
        self.func = None

    def change_skin(self,per):
        nb = int(per*8)
        cursor = pyglet.window.ImageMouseCursor(tman.textures[self.text[nb+8]],16,16)
        self.window.set_mouse_cursor(cursor)

Cur = Cursor()

#### CAMERA

SPEED = 20
RSPEED = 100

MOVE_Y = False

class Camera():

    def __init__(self,followin=None):

        self._X,self._Y = 0,0
        #self.BGX,self.BGY = 0,0
        self._dx,self._dy = 0,0

        self.d = 0.2

        self.followin = followin
        if followin:
            self.street = followin.street
        else:
            self.street = None

        self.activate = True
        self._static = False

    def update(self,street):

        ## if self.static == True alors la caméra va tout le temps bouger
        # si l'element followed bouge
        # si c'est False alors on laisse une "zone de liberté", où
        # le perso peut bouger sans bouger la cam

        if self.activate and not self.static:

            movin_box = self.followin.realbox
            speed = self.followin.realspeed
            x,xf = street.xxf

            if speed == 0:
                self._dx = 0
                return

            #X
            if movin_box[2] > 4*scr.size[0]/5 and (xf == None or street.rxf > scr.size[0] +speed):
                self.X -= self.followin.realspeed
            elif movin_box[0] < scr.size[0]/5 and (x == None or street.x < -speed):
                self.X += self.followin.realspeed

            if xf != None and street.rxf < scr.size[0]:
                if street.rxf < scr.size[0] - RSPEED:
                    self.X += RSPEED
                else:
                    self.X += SPEED
            elif x != None and street.x > 0:
                if street.x > RSPEED:
                    self.X -= RSPEED
                else:
                    self.X -= SPEED

            #Y
            if MOVE_Y:
                if movin_box[3] > 19*scr.size[1]/20:
                    self.lessy()
                elif movin_box[1] < scr.size[1]/20:
                    self.morey()


        elif self.activate and self.static:
            self.X = -self.followin.gex + scr.cx

    def tp(self,ge_x,real_x):

        ## ge_x -> position générale du perso après passage par la porte
        ## real_x -> position réelle à l'écran du perso AVANT passage par la porte
        self._X = - ge_x + real_x
        #print(ge_x,real_x,self._X)

    def tp2(self,ge_x):
        ## ge_x -> position générale du perso après passage par la porte
        ## utile dans certains cas
        self._X = - ge_x

    def follow(self,thg):
        self.followin = thg

    ##

    def _setX(self,X):
        if X != self._X:
            self._dx = self._X-X
            self._X = X
            #print(self._X,self._dx)
    def _X(self):
        return self._X
    def _setY(self,Y):
        if Y != self._Y:
            self._dy = self._Y-Y
            self._Y = Y
            #self.BGY = self.d*Y
    def _Y(self):
        return self._Y
    X = property(_X,_setX)
    Y = property(_Y,_setY)

    def _dx(self):
        return self._dx
    def _dy(self):
        return self._dy
    dx = property(_dx)
    dy = property(_dy)

    def _gstatic(self):
        return self._static
    def _sstatic(self,oth):
        self._static = oth
    static = property(_gstatic,_sstatic)

Cam = Camera()

class GodCamera():

    def __init__(self):

        self._X,self._Y = 0,0
        self._dx,self._dy = 0,0

        #self.d = 0.2

        self.speed = 30

    def activate(self,dir='L'):

        if dir == 'L':
            self.X += self.speed
        else:
            self.X -= self.speed

        Cam.activate = False

    def unactivate(self,perso):

        if not Cam.activate:
            self.X,self.Y = 0,0
            Cam.tp(perso.gex,scr.w/2)
            Cam.activate = True

    ###

    def _setX(self,X):
        if X != self._X:
            self._dx = self._X-X
            self._X = X
            #self.BGX = self.d*X
    def _X(self):
        return self._X
    def _setY(self,Y):
        if Y != self._Y:
            self._dy = self._Y-Y
            self._Y = Y
            #self.BGY = self.d*Y
    def _Y(self):
        return self._Y
    X = property(_X,_setX)
    Y = property(_Y,_setY)

    def _dx(self):
        return self._dx
    def _dy(self):
        return self._dy
    dx = property(_dx)
    dy = property(_dy)

GodCam = GodCamera()



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/menu.py


"""
CODED by deltasfer
enjoy
"""

from src import graphic as g
from src.colors import *
from collections import OrderedDict

class Menu:

    def __init__(self):

        self.arb = OrderedDict()

        self.arb['play']='play'
        param = OrderedDict()
        param['go home']='reset','go home','play'
        param['cheat']='reset','cheat','play'
        param['splum']='splum'
        param['nuits colorées'] = 'reset','roll_color','play'
        param['écran'] = OrderedDict()
        for i in range(len(g.scr.screens)):
            scr = g.scr.screens[i]
            nom = scr.get_device_name()
            param['écran'][nom] = 'scr'+str(i)

        self.arb['...'] = param
        self.arb['quit'] = 'quit'

        self.max_len = 8

        """
            play

            param
                cheh
                lezgo

            quit
        """


        self.point = '' ## exemple : "param,screen,opac"
        self.cursor = 0


        ## labels

        self.labids = {}
        (w,h) = g.scr.size
        padding = 100
        self.size = 30
        x = w/2
        y = h/2 + (self.max_len*self.size + (self.max_len-1)*padding)/2
        for i in range(self.max_len):
            y = y-padding
            self.labids[i] = g.lman.addLab('',(x,y),font_size=self.size,group='up',vis=False,anchor=('center','center'))

        self.actualise()

    def actualise(self):

        cont = list(self.get_dic().keys())

        vis = g.lman.labels[self.labids[0]].color[3]
        #print(list(c["yellow"])[:3],vis)

        g.lman.unhide(self.labids,True)
        for i in range(len(cont)):
            g.lman.set_text(self.labids[i],cont[i])
            if self.cursor == i:
                g.lman.modify(self.labids[i],size=50,color=list(c["yellow"])[:3]+[vis])
            else:
                g.lman.modify(self.labids[i],size=self.size,color=list(c["white"])[:3]+[vis])

    def reset(self):
        self.point = ''
        self.cursor = 0
        self.actualise()

    ##

    def click(self):

        if type(list(self.get_dic().values())[self.cursor]) == type(self.arb):
            name_dic = list(self.get_dic().keys())[self.cursor]
            if self.point == '':
                self.point = name_dic
            else:
                self.point = self.point+','+name_dic
            self.cursor = 0
            #print('waoouh',name_dic,self.point,self.cursor)
            self.actualise()
            return name_dic
        else:
            return list(self.get_dic().values())[self.cursor]

    def unclick(self):
        if self.point == '':
            return 'play','reset'
        else:
            self.point = ','.join(self.point.split(',')[:-1])
            print(self.point)
            self.cursor = 0
            self.actualise()

    def up(self):
        self.cursor -= 1
        if self.cursor < 0:
            self.cursor = self.get_current_maxcurs()-1
        self.actualise()

    def down(self):
        self.cursor += 1
        if self.cursor >= self.get_current_maxcurs():
            self.cursor = 0
        self.actualise()

    ##

    def get_dic(self):
        depth = 0
        if self.point != '':
            path = self.point.split(',')
            depth = len(path)

        dic = self.arb
        for i in range(depth):
            dic = dic[path[i]]
        return dic

    def get_current_maxcurs(self):
        return len(self.get_dic())

    def unhide(self,hide=False):
        ## unhide() AFFICHE le menu
        ## unhide(True) N'AFFICHE PAS le menu

        g.lman.unhide(self.labids,hide)
        self.actualise()



 _newfile_ :Z:\DESKTOP\CODING\plumegang/src/names.py


